{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `Transaction Context` in the sui move language?"}, {"role": "assistant", "content": "\n# Transaction Context\n\n\nEvery transaction has the execution context. The context is a set of predefined variables that are\navailable to the program during execution. For example, every transaction has a sender address, and\nthe transaction context contains a variable that holds the sender address.\n\nThe transaction context is available to the program through the `TxContext`\n struct. The struct is\ndefined in the `sui::tx_context`\n module and contains the following fields:\n\n```move`// File: sui-framework/sources/tx_context.move\n/// Information about the transaction currently being executed.\n/// This cannot be constructed by a transaction--it is a privileged object created by\n/// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.\nstruct TxContext has drop {\n    /// The address of the user that signed the current transaction\n    sender: address,\n    /// Hash of the current transaction\n    tx_hash: vector<u8>,\n    /// The current epoch number\n    epoch: u64,\n    /// Timestamp that the epoch started at\n    epoch_timestamp_ms: u64,\n    /// Counter recording the number of fresh id's created while executing\n    /// this transaction. Always 0 at the start of a transaction\n    ids_created: u64\n}\n`\n```\n\nTransaction context cannot be constructed manually or directly modified. It is created by the system\nand passed to the function as a reference in a transaction. Any function called in a\nTransaction has access to the context and can pass it into\nthe nested calls.\n\n\n`TxContext`\n has to be the last argument in the function signature.\n\n\n## Reading the Transaction Context\n\n\nWith only exception of the `ids_created`\n, all of the fields in the `TxContext`\n have getters. The\ngetters are defined in the `sui::tx_context`\n module and are available to the program. The getters\ndon't require `&mut`\n because they don't modify the context.\n\n```move`public fun some_action(ctx: &TxContext) {\n    let me = ctx.sender();\n    let epoch = ctx.epoch();\n    let digest = ctx.digest();\n    // ...\n}\n`\n```\n\n## Mutability\n\n\nThe `TxContext`\n is required to create new objects (or just `UID`\ns) in the system. New UIDs are\nderived from the transaction digest, and for the digest to be unique, there needs to be a changing\nparameter. Sui uses the `ids_created`\n field for that. Every time a new UID is created, the\n`ids_created`\n field is incremented by one. This way, the digest is always unique.\n\nInternally, it is represented as the `derive_id`\n function:\n\n```move`// File: sui-framework/sources/tx_context.move\nnative fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;\n`\n```\n\n## Generating unique addresses\n\n\nThe underlying `derive_id`\n function can also be utilized in your program to generate unique\naddresses. The function itself is not exposed, but a wrapper function `fresh_object_address`\n is\navailable in the `sui::tx_context`\n module. It may be useful if you need to generate a unique\nidentifier in your program.\n\n```move`// File: sui-framework/sources/tx_context.move\n/// Create an `address` that has not been used. As it is an object address, it will never\n/// occur as the address for a user.\n/// In other words, the generated address is a globally unique object ID.\npublic fun fresh_object_address(ctx: &mut TxContext): address {\n    let ids_created = ctx.ids_created;\n    let id = derive_id(*&ctx.tx_hash, ids_created);\n    ctx.ids_created = ids_created + 1;\n    id\n}\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How to  `Initializer Module ` in the sui move language?"}, {"role": "assistant", "content": "\n# Module Initializer\n\n\nA common use case in many applications is to run certain code just once when the package is\npublished. Imagine a simple store module that needs to create the main Store object upon its\npublication. In Sui, this is achieved by defining an `init`\n function within the module. This\nfunction will automatically be called when the module is published.\n\n\nAll of the modules' `init`\n functions are called during the publishing process. Currently, this\nbehavior is limited to the publish command and does not extend to\npackage upgrades.\n\n\n```move`module book::shop {\n    /// The Capability which grants the Shop owner the right to manage\n    /// the shop.\n    public struct ShopOwnerCap has key, store { id: UID }\n\n    /// The singular Shop itself, created in the `init` function.\n    public struct Shop has key {\n        id: UID,\n        /* ... */\n    }\n\n    // Called only once, upon module publication. It must be\n    // private to prevent external invocation.\n    fun init(ctx: &mut TxContext) {\n        // Transfers the ShopOwnerCap to the sender (publisher).\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        // Shares the Shop object.\n        transfer::share_object(Shop {\n            id: object::new(ctx)\n        });\n    }\n}\n`\n```\n\nIn the same package, another module can have its own `init`\n function, encapsulating distinct logic.\n\n```move`// In the same package as the `shop` module\nmodule book::bank {\n\n    public struct Bank has key {\n        id: UID,\n        /* ... */\n    }\n\n    fun init(ctx: &mut TxContext) {\n        transfer::share_object(Bank {\n            id: object::new(ctx)\n        });\n    }\n}\n`\n```\n\n## init features\n\n\nThe function is called on publish, if it is present in the module and follows the rules:\n\n* The function has to be named `init`\n, be private and have no return values.\n\n* Takes one or two arguments: [One Time Witness](./one-time-witness.html) (optional) and\n[TxContext](./transaction-context.html). With `TxContext always being the last argument.\n\n```move`fun init(ctx: &mut TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }\n`\n```\n\nTxContext can also be passed as immutable reference: `&TxContext`\n. However, practically speaking, it\nshould always be `&mut TxContext`\n since the `init`\n function can't access the onchain state and to\ncreate new objects it requires the mutable reference to the context.\n\n```move`fun init(ctx: &TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &TxContext) { /* ... */ }\n`\n```\n\n## Trust and security\n\n\nWhile `init`\n function can be used to create sensitive objects once, it is important to know that the\nsame object (eg. `StoreOwnerCap`\n from the first example) can still be created in another function.\nEspecially given that new functions can be added to the module during an upgrade. So the `init`\n\nfunction is a good place to set up the initial state of the module, but it is not a security measure\non its own.\n\nThere are ways to guarantee that the object was created only once, such as the\nOne Time Witness. And there are ways to limit or disable the upgrade of the\nmodule, which we will cover in the Package Upgrades chapter.\n\n## Next steps\n\n\nAs follows from the definition, the `init`\n function is guaranteed to be called only once when the\nmodule is published. So it is a good place to put the code that initializes module's objects and\nsets up the environment and configuration.\n\nFor example, if there's a Capability which is required for certain actions, it\nshould be created in the `init`\n function. In the next chapter we will talk about the `Capability`\n\npattern in more detail.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What is ` capability` in the sui move language?"}, {"role": "assistant", "content": "\n# Pattern: Capability\n\n\nIn programming, a capability is a token that gives the owner the right to perform a specific\naction. It is a pattern that is used to control access to resources and operations. A simple example\nof a capability is a key to a door. If you have the key, you can open the door. If you don't have\nthe key, you can't open the door. A more practical example is an Admin Capability which allows the\nowner to perform administrative operations, which regular users cannot.\n\n## Capability is an Object\n\n\nIn the Sui Object Model, capabilities are represented as objects.\nAn owner of an object can pass this object to a function to prove that they have the right to\nperform a specific action. Due to strict typing, the function taking a capability as an argument can\nonly be called with the correct capability.\n\n\nThere's a convention to name capabilities with the `Cap`\n suffix, for example, `AdminCap`\n or\n`KioskOwnerCap`\n.\n\n\n```move`module book::capability {\n    use std::string::String;\n    use sui::event;\n\n    /// The capability granting the application admin the right to create new\n    /// accounts in the system.\n    public struct AdminCap has key, store { id: UID }\n\n    /// The user account in the system.\n    public struct Account has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// A simple `Ping` event with no data.\n    public struct Ping has copy, drop { by: ID }\n\n    /// Creates a new account in the system. Requires the `AdminCap` capability\n    /// to be passed as the first argument.\n    public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n        Account {\n            id: object::new(ctx),\n            name,\n        }\n    }\n\n    /// Account, and any other objects, can also be used as a Capability in the\n    /// application. For example, to emit an event.\n    public fun send_ping(acc: &Account) {\n        event::emit(Ping {\n            by: acc.id.to_inner()\n        })\n    }\n\n    /// Updates the account name. Can only be called by the `Account` owner.\n    public fun update(account: &mut Account, name: String) {\n        account.name = name;\n    }\n}\n`\n```\n\n## Using init for Admin Capability\n\n\nA very common practice is to create a single `AdminCap`\n object on package publish. This way, the\napplication can have a setup phase where the admin account prepares the state of the application.\n\n```move`module book::admin_cap {\n    /// The capability granting the admin privileges in the system.\n    /// Created only once in the `init` function.\n    public struct AdminCap has key { id: UID }\n\n    /// Create the AdminCap object on package publish and transfer it to the\n    /// package owner.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            AdminCap { id: object::new(ctx) },\n            ctx.sender()\n        )\n    }\n}\n`\n```\n\n## Address check vs Capability\n\n\nUtilizing objects as capabilities is a relatively new concept in blockchain programming. And in\nother smart-contract languages, authorization is often performed by checking the address of the\nsender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities\nfor better security, discoverability, and code organization.\n\nLet's look at how the `new`\n function that creates a user would look like if it was using the address\ncheck:\n\n```move`/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n`\n```\n\nAnd now, let's see how the same function would look like with the capability:\n\n```move`/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n`\n```\n\nUsing capabilities has several advantages over the address check:\n\n* Migration of admin rights is easier with capabilities due to them being objects. In case of\naddress, if the admin address changes, all the functions that check the address need to be\nupdated - hence, require a [package upgrade](./package-upgrades.html).\n\n* Function signatures are more descriptive with capabilities. It is clear that the `new`\n function\nrequires the `AdminCap`\n to be passed as an argument. And this function can't be called without it.\n\n* Object Capabilities don't require extra checks in the function body, and hence, decrease the\nchance of a developer mistake.\n\n* An owned Capability also serves in discovery. The owner of the AdminCap can see the object in\ntheir account (via a Wallet or Explorer), and know that they have the admin rights. This is less\ntransparent with the address check.\n\nHowever, the address approach has its own advantages. For example, if an address is multisig, and\ntransaction building gets more complex, it might be easier to check the address. Also, if there's a\ncentral object of the application that is used in every function, it can store the admin address,\nand this would simplify migration. The central object approach is also valuable for revokable\ncapabilities, where the admin can revoke the capability from the user.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are ` Epoch and Time` in the sui move language?"}, {"role": "assistant", "content": "\n# Epoch and Time\n\n\nSui has two ways of accessing the current time: `Epoch`\n and `Time`\n. The former represents\noperational periods in the system and changed roughly every 24 hours. The latter represents the\ncurrent time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.\n\n## Epoch\n\n\nEpochs are used to separate the system into operational periods. During an epoch the validator set\nis fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial\nrole in the consensus algorithm and are used to determine the current validator set. They are also\nused as measurement in the staking mechanism.\n\nEpoch can be read from the transaction context:\n\n```move`public fun current_epoch(ctx: &TxContext) {\n    let epoch = ctx.epoch();\n    // ...\n}\n`\n```\n\nIt is also possible to get the unix timestamp of the epoch start:\n\n```move`public fun current_epoch_start(ctx: &TxContext) {\n    let epoch_start = ctx.epoch_timestamp_ms();\n    // ...\n}\n`\n```\n\nNormally, epochs are used in staking and system operations, however, in custom scenarios they can be\nused to emulate 24h periods. They are critical if an application relies on the staking logic or\nneeds to know the current validator set.\n\n## Time\n\n\nFor a more precise time measurement, Sui provides the `Clock`\n object. It is a system object that is\nupdated during checkpoints by the system, which stores the current time in milliseconds since the\nUnix Epoch. The `Clock`\n object is defined in the `sui::clock`\n module and has a reserved address\n`0x6`\n.\n\nClock is a shared object, but it a transaction attempting to access it mutably will fail. This\nlimitation allows parallel access to the `Clock`\n object, which is important for maintaining\nperformance.\n\n```move`// File: sui-framework/clock.move\n/// Singleton shared object that exposes time to Move calls.  This\n/// object is found at address 0x6, and can only be read (accessed\n/// via an immutable reference) by entry functions.\n///\n/// Entry Functions that attempt to accept `Clock` by mutable\n/// reference or value will fail to verify, and honest validators\n/// will not sign or execute transactions that use `Clock` as an\n/// input parameter, unless it is passed by immutable reference.\nstruct Clock has key {\n    id: UID,\n    /// The clock's timestamp, which is set automatically by a\n    /// system transaction every time consensus commits a\n    /// schedule, or by `sui::clock::increment_for_testing` during\n    /// testing.\n    timestamp_ms: u64,\n}\n`\n```\n\nThere is only one public function available in the `Clock`\n module - `timestamp_ms`\n. It returns the\ncurrent time in milliseconds since the Unix Epoch.\n\n```move`use sui::clock::Clock;\n\n/// Clock needs to be passed as an immutable reference.\npublic fun current_time(clock: &Clock) {\n    let time = clock.timestamp_ms();\n    // ...\n}\n`\n```\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are ` Collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `Dynamic Fields` in the sui move language?"}, {"role": "assistant", "content": "\n# Dynamic Fields\n\n\nSui Object model allows objects to be attached to other objects as dynamic fields. The behavior is\nsimilar to how a `Map`\n works in other programming languages. However, unlike a `Map`\n which in Move\nwould be strictly typed (we have covered it in the Collections section), dynamic\nfields allow attaching objects of any type. A similar approach from the world of frontend\ndevelopment would be a JavaScript Object type which allows storing any type of data dynamically.\n\n\nThere's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic\nfields can be used to store large amounts of data that don't fit into the object limit size.\n\n\nDynamic Fields allow for a wide range of applications, from splitting data into smaller parts to\navoid object size limit to attaching objects as a part of\napplication logic.\n\n## Definition\n\n\nDynamic Fields are defined in the `sui::dynamic_field`\n module of the\nSui Framework. They are attached to object's `UID`\n via a name, and can be\naccessed using that name. There can be only one field with a given name attached to an object.\n\nFile: sui-framework/sources/dynamic_field.move\n\n```move`/// Internal object used for storing the field and value\npublic struct Field<Name: copy + drop + store, Value: store> has key {\n    /// Determined by the hash of the object ID, the field name\n    /// value and it's type, i.e. hash(parent.id || name || Name)\n    id: UID,\n    /// The value for the name of this field\n    name: Name,\n    /// The value bound to this field\n    value: Value,\n}\n`\n```\n\nAs the definition shows, dynamic fields are stored in an internal `Field`\n object, which has the\n`UID`\n generated in a deterministic way based on the object ID, the field name, and the field type.\nThe `Field`\n object contains the field name and the value bound to it. The constraints on the `Name`\n\nand `Value`\n type parameters define the abilities that the key and value must have.\n\n## Usage\n\n\nThe methods available for dynamic fields are straightforward: a field can be added with `add`\n,\nremoved with `remove`\n, and read with `borrow`\n and `borrow_mut`\n. Additionally, the `exists_`\n method\ncan be used to check if a field exists (for stricter checks with type, there is an\n`exists_with_type`\n method).\n\n```move`module book::dynamic_collection {\n    // a very common alias for `dynamic_field` is `df` since the\n    // module name is quite long\n    use sui::dynamic_field as df;\n    use std::string::String;\n\n    /// The object that we will attach dynamic fields to.\n    public struct Character has key {\n        id: UID\n    }\n\n    // List of different accessories that can be attached to a character.\n    // They must have the `store` ability.\n    public struct Hat has key, store { id: UID, color: u32 }\n    public struct Mustache has key, store { id: UID }\n\n    #[test]\n    fun test_character_and_accessories() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Attach a hat to the character's UID\n        df::add(\n            &mut character.id,\n            b\"hat_key\",\n            Hat { id: object::new(ctx), color: 0xFF0000 }\n        );\n\n        // Similarly, attach a mustache to the character's UID\n        df::add(\n            &mut character.id,\n            b\"mustache_key\",\n            Mustache { id: object::new(ctx) }\n        );\n\n        // Check that the hat and mustache are attached to the character\n        //\n        assert!(df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        // Modify the color of the hat\n        let hat: &mut Hat = df::borrow_mut(&mut character.id, b\"hat_key\");\n        hat.color = 0x00FF00;\n\n        // Remove the hat and mustache from the character\n        let hat: Hat = df::remove(&mut character.id, b\"hat_key\");\n        let mustache: Mustache = df::remove(&mut character.id, b\"mustache_key\");\n\n        // Check that the hat and mustache are no longer attached to the character\n        assert!(!df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(!df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        sui::test_utils::destroy(character);\n        sui::test_utils::destroy(mustache);\n        sui::test_utils::destroy(hat);\n    }\n}\n`\n```\n\nIn the example above, we define a `Character`\n object and two different types of accessories that\ncould never be put together in a vector. However, dynamic fields allow us to store them together in\na single object. Both objects are attached to the `Character`\n via a `vector<u8>`\n (bytestring\nliteral), and can be accessed using their respective keys.\n\nAs you can see, when we attached the accessories to the Character, we passed them by value. In\nother words, both values were moved to a new scope, and their ownership was transferred to the\n`Character`\n object. If we changed the ownership of `Character`\n object, the accessories would have\nbeen moved with it.\n\nAnd the last important property of dynamic fields we should highlight is that they are accessed\nthrough their parent. This means that the `Hat`\n and `Mustache`\n objects are not directly accessible\nand follow the same rules as the parent object.\n\n## Foreign Types as Dynamic Fields\n\n\nDynamic fields allow objects to carry data of any type, including those defined in other modules.\nThis is possible due to their generic nature and relatively weak constraints on the type parameters.\nLet's illustrate this by attaching a few different values to a `Character`\n object.\n\n```move`let mut character = Character { id: object::new(ctx) };\n\n// Attach a `String` via a `vector<u8>` name\ndf::add(&mut character.id, b\"string_key\", b\"Hello, World!\".to_string());\n\n// Attach a `u64` via a `u32` name\ndf::add(&mut character.id, 1000u32, 1_000_000_000u64);\n\n// Attach a `bool` via a `bool` name\ndf::add(&mut character.id, true, false);\n`\n```\n\nIn this example we showed how different types can be used for both name and the value of a\ndynamic field. The `String`\n is attached via a `vector<u8>`\n name, the `u64`\n is attached via a `u32`\n\nname, and the `bool`\n is attached via a `bool`\n name. Anything is possible with dynamic fields!\n\n## Orphaned Dynamic Fields\n\n\n\nTo prevent orphaned dynamic fields, please, use\nDynamic Collection Types such as `Bag`\n as they track the dynamic\nfields and won't allow unpacking if there are attached fields.\n\n\nThe `object::delete()`\n function, which is used to delete a UID, does not track the dynamic fields,\nand cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the\ndynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic\nfields are still stored in the blockchain, but they will never become accessible again.\n\n```move`let hat = Hat { id: object::new(ctx), color: 0xFF0000 };\nlet mut character = Character { id: object::new(ctx) };\n\n// Attach a `Hat` via a `vector<u8>` name\ndf::add(&mut character.id, b\"hat_key\", hat);\n\n// ! DO NOT do this in your code\n// ! Danger - deleting the parent object\nlet Character { id } = character;\nid.delete();\n\n// ...`Hat` is now stuck in a limbo, it will never be accessible again\n`\n```\n\nOrphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed.\nOne way to avoid orphaned dynamic fields during unpacking on an object is to return the `UID`\n and\nstore it somewhere temporarily until the dynamic fields are removed and handled properly.\n\n## Custom Type as a Field Name\n\n\nIn the examples above, we used primitive types as field names since they have the required set of\nabilities. But dynamic fields get even more interesting when we use custom types as field names.\nThis allows for a more structured way of storing data, and also allows for protecting the field\nnames from being accessed by other modules.\n\n```move`/// A custom type with fields in it.\npublic struct AccessoryKey has copy, drop, store { name: String }\n\n/// An empty key, can be attached only once.\npublic struct MetadataKey has copy, drop, store {}\n`\n```\n\nTwo field names that we defined above are `AccessoryKey`\n and `MetadataKey`\n. The `AccessoryKey`\n has a\n`String`\n field in it, hence it can be used multiple times with different `name`\n values. The\n`MetadataKey`\n is an empty key, and can be attached only once.\n\n```move`let mut character = Character { id: object::new(ctx) };\n\n// Attaching via an `AccessoryKey { name: b\"hat\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"hat\".to_string() },\n    Hat { id: object::new(ctx), color: 0xFF0000 }\n);\n// Attaching via an `AccessoryKey { name: b\"mustache\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"mustache\".to_string() },\n    Mustache { id: object::new(ctx) }\n);\n\n// Attaching via a `MetadataKey`\ndf::add(&mut character.id, MetadataKey {}, 42);\n`\n```\n\nAs you can see, custom types do work as field names but as long as they can be constructed by the\nmodule, in other words - if they are internal to the module and defined in it. This limitation on\nstruct packing can open up new ways in the design of the application.\n\nThis approach is used in the Object Capability pattern, where an application can authorize a\nforeign object to perform operations in it while not exposing the capabilities to other modules.\n\n## Exposing UID\n\n\n\nMutable access to `UID`\n is a security risk. Exposing `UID`\n of your type as a mutable reference can\nlead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects\nthe Transfer to Object and\nDynamic Object Fields. Make sure to understand the implications before\nexposing the `UID`\n as a mutable reference.\n\n\nBecause dynamic fields are attached to `UID`\ns, their usage in other modules depends on whether the\n`UID`\n can be accessed. By default struct visibility protects the `id`\n field and won't let other\nmodules access it directly. However, if there's a public accessor method that returns a reference to\n`UID`\n, dynamic fields can be read in other modules.\n\n```move`/// Exposes the UID of the character, so that other modules can read\n/// dynamic fields.\npublic fun uid(c: &Character): &UID {\n    &c.id\n}\n`\n```\n\nIn the example above, we show how to expose the `UID`\n of a `Character`\n object. This solution may\nwork for some applications, however, it is important to remember that exposed `UID`\n allows reading\nany dynamic field attached to the object.\n\nIf you need to expose the `UID`\n only within the package, use a restrictive visibility, like\n`public(package)`\n, or even better - use more specific accessor methods that would allow only reading\nspecific fields.\n\n```move`/// Only allow modules in the same package to access the UID.\npublic(package) fun uid_package(c: &Character): &UID {\n    &c.id\n}\n\n/// Allow borrowing dynamic fields from the character.\npublic fun borrow<Name: copy + store + drop, Value: store>(\n    c: &Character,\n    n: Name\n): &Value {\n    df::borrow(&c.id, n)\n}\n`\n```\n\n## Dynamic Fields vs Fields\n\n\nDynamic Fields are more expensive than regular fields, as they require additional storage and costs\nfor accessing them. Their flexibility comes at a price, and it is important to understand the\nimplications when making a decision between using dynamic fields and regular fields.\n\n## Limits\n\n\nDynamic Fields are not subject to the object size limit,\nand can be used to store large amounts of data. However, they are still subject to the\ndynamic fields created limit, which is set to 1000 fields\nper transaction.\n\n## Applications\n\n\nDynamic Fields can play a crucial role in applications of any complexity. They open up a variety of\ndifferent use cases, from storing heterogeneous data to attaching objects as part of the application\nlogic. They allow for certain upgradeability practices\nbased on the ability to define them later and change the type of the field.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Object Fields and explain\nhow they differ from dynamic fields, and what are the implications of using them.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `Dynamic Object Fields` in the sui move language?"}, {"role": "assistant", "content": "\n# Dynamic Object Fields\n\n\n\nThis section expands on the Dynamic Fields. Please, read it first to\nunderstand the basics of dynamic fields.\n\n\nAnother variation of dynamic fields is dynamic object fields, which have certain differences from\nregular dynamic fields. In this section, we will cover the specifics of dynamic object fields and\nexplain how they differ from regular dynamic fields.\n\n\nGeneral recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields,\nespecially if there's no need for direct discovery through the ID. The extra costs of dynamic\nobject fields may not be justified by the benefits they provide.\n\n\n## Definition\n\n\nDynamic Object Fields are defined in the `sui::dynamic_object_fields`\n module in the\nSui Framework. They are similar to dynamic fields in many ways, but unlike\nthem, dynamic object fields have an extra constraint on the `Value`\n type. The `Value`\n must have a\ncombination of `key`\n and `store`\n, not just `store`\n as in the case of dynamic fields.\n\nThey're less explicit in their framework definition, as the concept itself is more abstract:\n\nFile: sui-framework/sources/dynamic_object_fields.move\n\n```move`/// Internal object used for storing the field and the name associated with the\n/// value. The separate type is necessary to prevent key collision with direct\n/// usage of dynamic_field\npublic struct Wrapper<Name> has copy, drop, store {\n    name: Name,\n}\n`\n```\n\nUnlike `Field`\n type in the Dynamic Fields section, the `Wrapper`\n\ntype only stores the name of the field. The value is the object itself, and is not wrapped.\n\nThe constraints on the `Value`\n type become visible in the methods available for dynamic object\nfields. Here's the signature for the `add`\n function:\n\n```move`/// Adds a dynamic object field to the object `object: &mut UID` at field\n/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object\n/// already has that field with that name.\npublic fun add<Name: copy + drop + store, Value: key + store>(\n    // we use &mut UID in several spots for access control\n    object: &mut UID,\n    name: Name,\n    value: Value,\n) { /* implementation omitted */ }\n`\n```\n\nThe rest of the methods which are identical to the ones in the\nDynamic Fields section have the same constraints on the `Value`\n type.\nLet's list them for reference:\n\n* `add`\n - adds a dynamic object field to the object\n\n* `remove`\n - removes a dynamic object field from the object\n\n* `borrow`\n - borrows a dynamic object field from the object\n\n* `borrow_mut`\n - borrows a mutable reference to a dynamic object field from the object\n\n* `exists_`\n - checks if a dynamic object field exists\n\n* `exists_with_type`\n - checks if a dynamic object field exists with a specific type\n\nAdditionally, there is an `id`\n method which returns the `ID`\n of the `Value`\n object without\nspecifying its type.\n\n## Usage & Differences with Dynamic Fields\n\n\nThe main difference between dynamic fields and dynamic object fields is that the latter allows\nstoring only objects as values. This means that you can't store primitive types like `u64`\n or\n`bool`\n. It may be considered a limitation, if not for the fact that dynamic object fields are not\nwrapped into a separate object.\n\n\nThe relaxed requirement for wrapping keeps the object available for off-chain discovery via its\nID. However, this property may not be outstanding if wrapped object indexing is implemented,\nmaking the dynamic object fields a redundant feature.\n\n\n```move`module book::dynamic_object_field {\n    use std::string::String;\n\n    // there are two common aliases for the long module name: `dof` and\n    // `ofield`. Both are commonly used and met in different projects.\n    use sui::dynamic_object_field as dof;\n    use sui::dynamic_field as df;\n\n    /// The `Character` that we will use for the example\n    public struct Character has key { id: UID }\n\n    /// Metadata that doesn't have the `key` ability\n    public struct Metadata has store, drop { name: String }\n\n    /// Accessory that has the `key` and `store` abilities.\n    public struct Accessory has key, store { id: UID }\n\n    #[test]\n    fun equip_accessory() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Create an accessory and attach it to the character\n        let hat = Accessory { id: object::new(ctx) };\n\n        // Add the hat to the character. Just like with `dynamic_fields`\n        dof::add(&mut character.id, b\"hat_key\", hat);\n\n        // However for non-key structs we can only use `dynamic_field`\n        df::add(&mut character.id, b\"metadata_key\", Metadata {\n            name: b\"John\".to_string()\n        });\n\n        // Borrow the hat from the character\n        let hat_id = dof::id(&character.id, b\"hat_key\").extract(); // Option<ID>\n        let hat_ref: &Accessory = dof::borrow(&character.id, b\"hat_key\");\n        let hat_mut: &mut Accessory = dof::borrow_mut(&mut character.id, b\"hat_key\");\n        let hat: Accessory = dof::remove(&mut character.id, b\"hat_key\");\n\n        // Clean up, Metadata is an orphan now.\n        sui::test_utils::destroy(hat);\n        sui::test_utils::destroy(character);\n    }\n}\n`\n```\n\n## Pricing Differences\n\n\nDynamic Object Fields come a little more exensive than dynamic fields. Because of their internal\nstructure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of\nadding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.\n\n## Next Steps\n\n\nBoth dynamic field and dynamic object fields are powerful features which allow for innovative\nsolutions in applications. However, they are relatively low-level and require careful handling to\navoid orphaned fields. In the next section, we will introduce a higher-level abstraction -\nDynamic Collections - which can help with managing dynamic fields and\nobjects more effectively.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `Dynamic Collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Dynamic Collections\n\n\nSui Framework offers a variety of collection types that build on the\ndynamic fields and dynamic object fields\nconcepts. These collections are designed to be a safer and more understandable way to store and\nmanage dynamic fields and objects.\n\nFor each collection type we will specify the primitive they use, and the specific features they\noffer.\n\n\nUnlike dynamic (object) fields which operate on UID, collection types have their own type and\nallow calling associated functions.\n\n\n## Common Concepts\n\n\nAll of the collection types share the same set of methods, which are:\n\n* `add`\n - adds a field to the collection\n\n* `remove`\n - removes a field from the collection\n\n* `borrow`\n - borrows a field from the collection\n\n* `borrow_mut`\n - borrows a mutable reference to a field from the collection\n\n* `contains`\n - checks if a field exists in the collection\n\n* `length`\n - returns the number of fields in the collection\n\n* `is_empty`\n - checks if the `length`\n is 0\n\nAll collection types support index syntax for `borrow`\n and `borrow_mut`\n methods. If you see square\nbrackets in the examples, they are translated into `borrow`\n and `borrow_mut`\n calls.\n\n```move`let hat: &Hat = &bag[b\"key\"];\nlet hat_mut: &mut Hat = &mut bag[b\"key\"];\n\n// is equivalent to\nlet hat: &Hat = bag.borrow(b\"key\");\nlet hat_mut: &mut Hat = bag.borrow_mut(b\"key\");\n`\n```\n\nIn the examples we won't focus on these functions, but rather on the differences between the\ncollection types.\n\n## Bag\n\n\nBag, as the name suggests, acts as a \"bag\" of heterogeneous values. It is a simple, non-generic type\nthat can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and\ncan't be destroyed if it's not empty.\n\n```move`// File: sui-framework/sources/bag.move\npublic struct Bag has key, store {\n    /// the ID of this bag\n    id: UID,\n    /// the number of key-value pairs in the bag\n    size: u64,\n}\n`\n```\n\nDue to Bag storing any types, the extra methods it offers is:\n\n* `contains_with_type`\n - checks if a field exists with a specific type\n\nUsed as a struct field:\n\n```move`/// Imported from the `sui::bag` module.\nuse sui::bag::{Self, Bag};\n\n/// An example of a `Bag` as a struct field.\npublic struct Carrier has key {\n    id: UID,\n    bag: Bag\n}\n`\n```\n\nUsing the Bag:\n\n```move`let mut bag = bag::new(ctx);\n\n// bag has the `length` function to get the number of elements\nassert!(bag.length() == 0, 0);\n\nbag.add(b\"my_key\", b\"my_value\".to_string());\n\n// length has changed to 1\nassert!(bag.length() == 1, 1);\n\n// in order: `borrow`, `borrow_mut` and `remove`\n// the value type must be specified\nlet field_ref: &String = &bag[b\"my_key\"];\nlet field_mut: &mut String = &mut bag[b\"my_key\"];\nlet field: String = bag.remove(b\"my_key\");\n\n// length is back to 0 - we can unpack\nbag.destroy_empty();\n`\n```\n\n## ObjectBag\n\n\nDefined in the `sui::object_bag`\n module. Identical to Bag, but uses\ndynamic object fields internally. Can only store objects as values.\n\n## Table\n\n\nTable is a typed dynamic collection that has a fixed type for keys and values. It is defined in the\n`sui::table`\n module.\n\n```move`// File: sui-framework/sources/table.move\npublic struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {\n    /// the ID of this table\n    id: UID,\n    /// the number of key-value pairs in the table\n    size: u64,\n}\n`\n```\n\nUsed as a struct field:\n\n```move`/// Imported from the `sui::table` module.\nuse sui::table::{Self, Table};\n\n/// Some record type with `store`\npublic struct Record has store { /* ... */ }\n\n/// An example of a `Table` as a struct field.\npublic struct UserRegistry has key {\n    id: UID,\n    table: Table<address, Record>\n}\n`\n```\n\nUsing the Table:\n\n```move`#[test] fun test_table() {\nlet ctx = &mut tx_context::dummy();\n\n// Table requires explicit type parameters for the key and value\n// ...but does it only once in initialization.\nlet mut table = table::new<address, String>(ctx);\n\n// table has the `length` function to get the number of elements\nassert!(table.length() == 0, 0);\n\ntable.add(@0xa11ce, b\"my_value\".to_string());\ntable.add(@0xb0b, b\"another_value\".to_string());\n\n// length has changed to 2\nassert!(table.length() == 2, 2);\n\n// in order: `borrow`, `borrow_mut` and `remove`\nlet addr_ref = &table[@0xa11ce];\nlet addr_mut = &mut table[@0xa11ce];\n\n// removing both values\nlet _addr = table.remove(@0xa11ce);\nlet _addr = table.remove(@0xb0b);\n\n// length is back to 0 - we can unpack\ntable.destroy_empty();\n`\n```\n\n## ObjectTable\n\n\nDefined in the `sui::object_table`\n module. Identical to Table, but uses\ndynamic object fields internally. Can only store objects as values.\n\n## Summary\n\n\n* [Bag](#bag) - a simple collection that can store any type of data\n\n* [ObjectBag](#objectbag) - a collection that can store only objects\n\n* [Table](#table) - a typed dynamic collection that has a fixed type for keys and values\n\n* [ObjectTable](#objecttable) - same as Table, but can only store objects\n\n\n## LinkedTable\n\n\nThis section is coming soon!\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `One Time Witness, (OTW)` in the sui move language?"}, {"role": "assistant", "content": "\n# One Time Witness\n\n\nWhile regular Witness is a great way to statically prove the ownership of a\ntype, there are cases where we need to ensure that a Witness is instantiated only once. And this is\nthe purpose of the One Time Witness (OTW).\n\n\n## Definition\n\n\nThe OTW is a special type of Witness that can be used only once. It cannot be manually\ncreated and it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these rules:\n\n1. Has only `drop`\n ability.\n2. Has no fields.\n3. Is not a generic type.\n4. Named after the module with all uppercase letters.\n\nHere is an example of an OTW:\n\n```move`module book::one_time {\n    /// The OTW for the `book::one_time` module.\n    /// Only `drop`, no fields, no generics, all uppercase.\n    public struct ONE_TIME has drop {}\n\n    /// Receive the instance of `ONE_TIME` as the first argument.\n    fun init(otw: ONE_TIME, ctx: &mut TxContext) {\n        // do something with the OTW\n    }\n}\n`\n```\n\nThe OTW cannot be constructed manually, and any code attempting to do so will result in\na compilation error. The OTW can be received as the first argument in the\nmodule initializer. And because the `init`\n function is called only once\nper module, the OTW is guaranteed to be instantiated only once.\n\n## Enforcing the OTW\n\n\nTo check if a type is an OTW, `sui::types`\n module of the\nSui Framework offers a special function `is_one_time_witness`\n that can be used\nto check if the type is an OTW.\n\n```move`use sui::types;\n\nconst ENotOneTimeWitness: u64 = 1;\n\n/// Takes an OTW as an argument, aborts if the type is not OTW.\npublic fun takes_witness<T: drop>(otw: T) {\n    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);\n}\n`\n```\n\n\n\n## Summary\n\n\nThe OTW pattern is a great way to ensure that a type is used only once. Most of the\ndevelopers should understand how to define and receive the OTW, while the OTW checks and enforcement\nis mostly needed in libraries and frameworks. For example, the `sui::coin`\n module requires an OTW\nin the `coin::create_currency`\n method, therefore enforcing that the `coin::TreasuryCap`\n\nis created only once.\n\nOTW is a powerful tool that lays the foundation for the Publisher\nobject, which we will cover in the next section.\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `Publisher Authority` in the sui move language?"}, {"role": "assistant", "content": "\n# Publisher Authority\n\n\nIn application design and development, it is often needed to prove publisher authority. This is\nespecially important in the context of digital assets, where the publisher may enable or disable\ncertain features for their assets. The Publisher Object is an object, defined in the\nSui Framework, that allows the publisher to prove their authority over a\ntype.\n\n## Definition\n\n\nThe Publisher object is defined in the `sui::package`\n module of the Sui Framework. It is a very\nsimple, non-generic object that can be initialized once per module (and multiple times per package)\nand is used to prove the authority of the publisher over a type. To claim a Publisher object, the\npublisher must present a One Time Witness to the `package::claim`\n function.\n\n```move`// File: sui-framework/sources/package.move\npublic struct Publisher has key, store {\n    id: UID,\n    package: String,\n    module_name: String,\n}\n`\n```\n\n\nIf you're not familiar with the One Time Witness, you can read more about it\nhere.\n\n\nHere's a simple example of claiming a `Publisher`\n object in a module:\n\n```move`module book::publisher {\n    /// Some type defined in the module.\n    public struct Book {}\n\n    /// The OTW for the module.\n    public struct PUBLISHER has drop {}\n\n    /// Uses the One Time Witness to claim the Publisher object.\n    fun init(otw: PUBLISHER, ctx: &mut TxContext) {\n        // Claim the Publisher object.\n        let publisher = sui::package::claim(otw, ctx);\n\n        // Usually it is transferred to the sender.\n        // It can also be stored in another object.\n        transfer::public_transfer(publisher, ctx.sender())\n    }\n}\n`\n```\n\n## Usage\n\n\nThe Publisher object has two functions associated with it which are used to prove the publisher's\nauthority over a type:\n\n```move`// Checks if the type is from the same module, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_module<Book>(), 0);\n\n// Checks if the type is from the same package, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_package<Book>(), 0);\n`\n```\n\n## Publisher as Admin Role\n\n\nFor small applications or simple use cases, the Publisher object can be used as an admin\ncapability. While in the broader context, the Publisher object has control over\nsystem configurations, it can also be used to manage the application's state.\n\n```move`/// Some action in the application gated by the Publisher object.\npublic fun admin_action(cap: &Publisher, /* app objects... */ param: u64) {\n    assert!(cap.from_module<Book>(), ENotAuthorized);\n\n    // perform application-specific action\n}\n`\n```\n\nHowever, Publisher misses some native properties of Capabilities, such as type\nsafety and expressiveness. The signature for the `admin_function`\n is not very explicit, can be\ncalled by anyone else. And due to `Publisher`\n object being standard, there now is a risk of\nunauthorized access if the `from_module`\n check is not performed. So it's important to be cautious\nwhen using the `Publisher`\n object as an admin role.\n\n## Role on Sui\n\n\nPublisher is required for certain features on Sui. Object Display can be created\nonly by the Publisher, and TransferPolicy - an important component of the Kiosk system - also\nrequires the Publisher object to prove ownership of the type.\n\n## Next Steps\n\n\nIn the next chapter we will cover the first feature that requires the Publisher object - Object\nDisplay - a way to describe objects for clients, and standardize metadata. A must-have for\nuser-friendly applications.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are `Object Display` in the sui move language?"}, {"role": "assistant", "content": "\n# Object Display\n\n\nObjects on Sui are explicit in their structure and behavior and can be displayed in an\nunderstandable way. However, to support richer metadata for clients, there's a standard and\nefficient way of \"describing\" them to the client - the `Display`\n object defined in the\nSui Framework.\n\n## Background\n\n\nHistorically, there were different attempts to agree on a standard structure of an object so it can\nbe displayed in a user interface. One of the approaches was to define certain fields in the object\nstruct which, when present, would be used in the UI. This approach was not flexible enough and\nrequired developers to define the same fields in every object, and sometimes the fields did not make\nsense for the object.\n\n```move`/// An attempt to standardize the object structure for display.\npublic struct CounterWithDisplay has key {\n    id: UID,\n    /// If this field is present it will be displayed in the UI as `name`.\n    name: String,\n    /// If this field is present it will be displayed in the UI as `description`.\n    description: String,\n    // ...\n    image: String,\n    /// Actual fields of the object.\n    counter: u64,\n    // ...\n}\n`\n```\n\nIf any of the fields contained static data, it would be duplicated in every object. And, since Move\ndoes not have interfaces, it is not possible to know if an object has a specific field without\n\"manually\" checking the object's type, which makes the client fetching more complex.\n\n## Object Display\n\n\nTo address these issues, Sui introduces a standard way of describing an object for display. Instead\nof defining fields in the object struct, the display metadata is stored in a separate object, which\nis associated with the type. This way, the display metadata is not duplicated, and it is easy to\nextend and maintain.\n\nAnother important feature of Sui Display is the ability to define templates and use object fields in\nthose templates. Not only it allows for a more flexible display, but it also frees the developer\nfrom the need to define the same fields with the same names and types in every object.\n\n\nThe Object Display is natively supported by the Sui Fullnode, and the client can fetch the display\nmetadata for any object if the object type has a Display associated with it.\n\n\n```move`module book::arena {\n    use std::string::String;\n    use sui::package;\n    use sui::display;\n\n    /// The One Time Witness to claim the `Publisher` object.\n    public struct ARENA has drop {}\n\n    /// Some object which will be displayed.\n    public struct Hero has key {\n        id: UID,\n        class: String,\n        level: u64,\n    }\n\n    /// In the module initializer we create the `Publisher` object, and then\n    /// the Display for the `Hero` type.\n    fun init(otw: ARENA, ctx: &mut TxContext) {\n        let publisher = package::claim(otw, ctx);\n        let mut display = display::new<Hero>(&publisher, ctx);\n\n        display.add(\n            b\"name\".to_string(),\n            b\"{class} (lvl. {level})\".to_string()\n        );\n\n        display.add(\n            b\"description\".to_string(),\n            b\"One of the greatest heroes of all time. Join us!\".to_string()\n        );\n\n        display.add(\n            b\"link\".to_string(),\n            b\"https://example.com/hero/{id}\".to_string()\n        );\n\n        display.add(\n            b\"image_url\".to_string(),\n            b\"https://example.com/hero/{class}.jpg\".to_string()\n        );\n\n        // Update the display with the new data.\n        // Must be called to apply changes.\n        display.update_version();\n\n        transfer::public_transfer(publisher, ctx.sender());\n        transfer::public_transfer(display, ctx.sender());\n    }\n}\n`\n```\n\n## Creator Privilege\n\n\nWhile the objects can be owned by accounts and may be a subject to\nTrue Ownership, the Display can be owned\nby the creator of the object. This way, the creator can update the display metadata and apply the\nchanges globally without the need to update every object. The creator can also transfer Display to\nanother account or even build an application around the object with custom functionality to manage\nthe metadata.\n\n## Standard Fields\n\n\nThe fields that are supported most widely are:\n\n* `name`\n - A name for the object. The name is displayed when users view the object.\n\n* `description`\n - A description for the object. The description is displayed when users view the\nobject.\n\n* `link`\n - A link to the object to use in an application.\n\n* `image_url`\n - A URL or a blob with the image for the object.\n\n* `thumbnail_url`\n - A URL to a smaller image to use in wallets, explorers, and other products as a\npreview.\n\n* `project_url`\n - A link to a website associated with the object or creator.\n\n* `creator`\n - A string that indicates the object creator.\n\n\nPlease, refer to the Sui Documentation for the most\nup-to-date list of supported fields.\n\n\nWhile there's a standard set of fields, the Display object does not enforce them. The developer can\ndefine any fields they need, and the client can use them as they see fit. Some applications may\nrequire additional fields, and omit other, and the Display is flexible enough to support them.\n\n## Working with Display\n\n\nThe `Display`\n object is defined in the `sui::display`\n module. It is a generic struct that takes a\nphantom type as a parameter. The phantom type is used to associate the `Display`\n object with the\ntype it describes. The `fields`\n of the `Display`\n object are a `VecMap`\n of key-value pairs, where the\nkey is the field name and the value is the field value. The `version`\n field is used to version the\ndisplay metadata, and is updated on the `update_display`\n call.\n\nFile: sui-framework/sources/display.move\n\n```move`struct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n`\n```\n\nThe Publisher object is required to a new Display, since it serves as the proof of\nownership of type.\n\n## Template Syntax\n\n\nCurrently, Display supports simple string interpolation and can use struct fields (and paths) in its\ntemplates. The syntax is trivial - `{path}`\n is replaced with the value of the field at the path. The\npath is a dot-separated list of field names, starting from the root object in case of nested fields.\n\n```move`/// Some common metadata for objects.\npublic struct Metadata has store {\n    name: String,\n    description: String,\n    published_at: u64\n}\n\n/// The type with nested Metadata field.\npublic struct LittlePony has key, store {\n    id: UID,\n    image_url: String,\n    metadata: Metadata\n}\n`\n```\n\nThe Display for the type `LittlePony`\n above could be defined as follows:\n\n```move`{\n  \"name\": \"Just a pony\",\n  \"image_url\": \"{image_url}\",\n  \"description\": \"{metadata.description}\"\n}\n`\n```\n\n## Multiple Display Objects\n\n\nThere's no restriction to how many `Display<T>`\n objects can be created for a specific `T`\n. However,\nthe most recently updated `Display<T>`\n will be used by the fullnode.\n\n## Further Reading\n\n\n* [Sui Object Display](https://docs.sui.io/standards/display) is Sui Documentation\n\n* [Publisher](./publisher.html) - the representation of the creator\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " How to use `events` in the sui move language?"}, {"role": "assistant", "content": "\n# Events\n\n\nEvents are a way to notify off-chain listeners about on-chain events. They are used to emit\nadditional information about the transaction that is not stored - and, hence, can't be accessed -\non-chain. Events are emitted by the `sui::event`\n module located in the\nSui Framework.\n\n\nAny custom type with the copy and\ndrop abilities can be emitted as an event.\nSui Verifier requires the type to be internal to the module.\n\n\n```move`// File: sui-framework/sources/event.move\nmodule sui::event {\n    /// Emit a custom Move event, sending the data offchain.\n    ///\n    /// Used for creating custom indexes and tracking onchain\n    /// activity in a way that suits a specific application the most.\n    ///\n    /// The type `T` is the main way to index the event, and can contain\n    /// phantom parameters, eg `emit(MyEvent<phantom T>)`.\n    public native fun emit<T: copy + drop>(event: T);\n}\n`\n```\n\n## Emitting Events\n\n\nEvents are emitted using the `emit`\n function in the `sui::event`\n module. The function takes a single\nargument - the event to be emitted. The event data is passed by value,\n\n```move`module book::events {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n    use sui::event;\n\n    /// The item that can be purchased.\n    public struct Item has key { id: UID }\n\n    /// Event emitted when an item is purchased. Contains the ID of the item and\n    /// the price for which it was purchased.\n    public struct ItemPurchased has copy, drop {\n        item: ID,\n        price: u64\n    }\n\n    /// A marketplace function which performs the purchase of an item.\n    public fun purchase(coin: Coin<SUI>, ctx: &mut TxContext) {\n        let item = Item { id: object::new(ctx) };\n\n        // Create an instance of `ItemPurchased` and pass it to `event::emit`.\n        event::emit(ItemPurchased {\n            item: object::id(&item),\n            price: coin.value()\n        });\n\n        // Omitting the rest of the implementation to keep the example simple.\n        abort 0\n    }\n}\n`\n```\n\nThe Sui Verifier requires the type passed to the `emit`\n function to be internal to the module. So\nemitting a type from another module will result in a compilation error. Primitive types, although\nthey match the copy and drop requirement, are not allowed to be emitted as events.\n\n## Event Structure\n\n\nEvents are a part of the transaction result and are stored in the transaction effects. As such,\nthey natively have the `sender`\n field which is the address who sent the transaction. So adding a\n\"sender\" field to the event is not necessary. Similarly, event metadata contains the timestamp. But\nit is important to note that the timestamp is relative to the node and may vary a little from node\nto node.\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What is  `Sui framework` in the sui move language?"}, {"role": "assistant", "content": "\n# Sui Framework\n\n\nSui Framework is a default dependency set in the Package Manifest. It\ndepends on the Standard Library and provides Sui-specific\nfeatures, including the interaction with the storage, and Sui-specific native types and modules.\n\nFor convenience, we grouped the modules in the Sui Framework into multiple categories. But they're\nstill part of the same framework.\n\n## Core\n\n\n\n\n| Module | Description | Chapter |\n|-----------------------------------|\n [sui::address](https://docs.sui.io/references/framework/sui-framework/address) | Adds conversion methods to the [address type](./../move-basics/address.html) | [Address](./../move-basics/address.html) |\n [sui::transfer](https://docs.sui.io/references/framework/sui-framework/transfer) | Implements the storage operations for Objects | [It starts with an Object](./../object) |\n [sui::tx_context](https://docs.sui.io/references/framework/sui-framework/tx_context) | Contains the `TxContext`\n struct and methods to read it | [Transaction Context](./transaction-context.html) |\n [sui::object](https://docs.sui.io/references/framework/sui-framework/object) | Defines the `UID`\n and `ID`\n type, required for creating objects | [It starts with an Object](./../object) |\n [sui::clock](https://docs.sui.io/references/framework/sui-framework/clock) | Defines the `Clock`\n type and its methods | [Epoch and Time](./epoch-and-time.html) |\n [sui::dynamic_field](https://docs.sui.io/references/framework/sui-framework/dynamic_field) | Implements methods to add, use and remove dynamic fields | [Dynamic Fields](./dynamic-fields.html) |\n [sui::dynamic_object_field](https://docs.sui.io/references/framework/sui-framework/dynamic_object_field) | Implements methods to add, use and remove dynamic object fields | [Dynamic Object Fields](./dynamic-object-fields.html) |\n [sui::event](https://docs.sui.io/references/framework/sui-framework/event) | Allows emitting events for off-chain listeners | [Events](./events.html) |\n [sui::package](https://docs.sui.io/references/framework/sui-framework/package) | Defines the `Publisher`\n type and package upgrade methods | [Publisher](./publisher.html), [Package Upgrades](./package-upgrades.html) |\n [sui::display](https://docs.sui.io/references/framework/sui-framework/display) | Implements the `Display`\n object and ways to create and update it | [Display](./display.html) |\n\n\n\n## Collections\n\n\n\n| Module | Description | Chapter |\n|-----------------------------------|\n [sui::vec_set](https://docs.sui.io/references/framework/sui-framework/vec_set) | Implements a set type | [Collections](./collections.html) |\n [sui::vec_map](https://docs.sui.io/references/framework/sui-framework/vec_map) | Implements a map with vector keys | [Collections](./collections.html) |\n [sui::table](https://docs.sui.io/references/framework/sui-framework/table) | Implements the `Table`\n type and methods to interact with it | [Dynamic Collections](./dynamic-collections.html) |\n [sui::linked_table](https://docs.sui.io/references/framework/sui-framework/linked_table) | Implements the `LinkedTable`\n type and methods to interact with it | [Dynamic Collections](./dynamic-collections.html) |\n [sui::bag](https://docs.sui.io/references/framework/sui-framework/bag) | Implements the `Bag`\n type and methods to interact with it | [Dynamic Collections](./dynamic-collections.html) |\n [sui::object_table](https://docs.sui.io/references/framework/sui-framework/object_table) | Implements the `ObjectTable`\n type and methods to interact with it | [Dynamic Collections](./dynamic-collections.html) |\n [sui::object_bag](https://docs.sui.io/references/framework/sui-framework/object_bag) | Implements the `ObjectBag`\n type and methods to interact with it | [Dynamic Collections](./dynamic-collections.html) |\n\n\n\n## Utilities\n\n\n\n| Module | Description | Chapter |\n|-----------------------------------|\n [sui::bcs](https://docs.sui.io/references/framework/sui-framework/bcs) | Implements the BCS encoding and decoding functions | [Binary Canonical Serialization](./bcs.html) |\n\n\n\n## Exported Addresses\n\n\nSui Framework exports two named addresses: `sui = 0x2`\n and `std = 0x1`\n from the std dependency.\n\n```move`[addresses]\nsui = \"0x2\"\n\n# Exported from the MoveStdlib dependency\nstd = \"0x1\"\n`\n```\n\n## Implicit Imports\n\n\nJust like with Standard Library, some of\nthe modules and types are imported implicitly in the Sui Framework. This is the list of modules and\ntypes that are available without explicit `use`\n import:\n\n* sui::object\n\n* sui::object::ID\n\n* sui::object::UID\n\n* sui::tx_context\n\n* sui::tx_context::TxContext\n\n* sui::transfer\n\n## Source Code\n\n\nThe source code of the Sui Framework is available in the\nSui repository.\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What are  `Binary Canonical Serialization (BCS)` in the sui move language?"}, {"role": "assistant", "content": "\n# Binary Canonical Serialization\n\n\nBinary Canonical Serialization (BCS) is a binary encoding format for structured data. It was\noriginally designed in Diem, and became the standard serialization format for Move. BCS is simple,\nefficient, deterministic, and easy to implement in any programming language.\n\n\nThe full format specification is available in the\nBCS repository.\n\n\n## Format\n\n\nBCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit\n(empty value), fixed and variable-length sequences, and maps. The format is designed to be\ndeterministic, meaning that the same data will always be serialized to the same bytes.\n\n\n\"BCS is not a self-describing format. As such, in order to deserialize a message, one must know\nthe message type and layout ahead of time\" from the README\n\n\nIntegers are stored in little-endian format, and variable-length integers are encoded using a\nvariable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations\nare stored as the index of the variant followed by the data, and maps are stored as an ordered\nsequence of key-value pairs.\n\nStructs are treated as a sequence of fields, and the fields are serialized in the order they are\ndefined in the struct. The fields are serialized using the same rules as the top-level data.\n\n## Using BCS\n\n\nThe Sui Framework includes the sui::bcs module for encoding and decoding data. Encoding functions are native to the VM, and decoding functions are implemented in Move.\n\n## Encoding\n\n\nTo encode data, use the `bcs::to_bytes`\n function, which converts data references into byte vectors. This function supports encoding any types, including structs.\n\n```move`// File: move-stdlib/sources/bcs.move\npublic native fun to_bytes<T>(t: &T): vector<u8>;\n`\n```\n\nThe following example shows how to encode a struct using BCS. The `to_bytes`\n function can take any\nvalue and encode it as a vector of bytes.\n\n```move`use sui::bcs;\n\n// 0x01 - a single byte with value 1 (or 0 for false)\nlet bool_bytes = bcs::to_bytes(&true);\n// 0x2a - just a single byte\nlet u8_bytes = bcs::to_bytes(&42u8);\n// 0x000000000000002a - 8 bytes\nlet u64_bytes = bcs::to_bytes(&42u64);\n// address is a fixed sequence of 32 bytes\n// 0x0000000000000000000000000000000000000000000000000000000000000002\nlet addr = bcs::to_bytes(&@sui);\n`\n```\n\n### Encoding a Struct\n\n\nStructs encode similarly to simple types. Here is how to encode a struct using BCS:\n\n```move`let data = CustomData {\n    num: 42,\n    string: b\"hello, world!\".to_string(),\n    value: true\n};\n\nlet struct_bytes = bcs::to_bytes(&data);\n\nlet mut custom_bytes = vector[];\ncustom_bytes.append(bcs::to_bytes(&42u8));\ncustom_bytes.append(bcs::to_bytes(&b\"hello, world!\".to_string()));\ncustom_bytes.append(bcs::to_bytes(&true));\n\n// struct is just a sequence of fields, so the bytes should be the same!\nassert!(&struct_bytes == &custom_bytes, 0);\n`\n```\n\n## Decoding\n\n\nBecause BCS does not self-describe and Move is statically typed, decoding requires prior knowledge of the data type. The `sui::bcs`\n module provides various functions to assist with this process.\n\n### Wrapper API\n\n\nBCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the\ncaller to peel off the data by calling different decoding functions, prefixed with `peel_*`\n. The\ndata is split off the bytes, and the remainder bytes are kept in the wrapper until the\n`into_remainder_bytes`\n function is called.\n\n```move`use sui::bcs;\n\n// BCS instance should always be declared as mutable\nlet mut bcs = bcs::new(x\"010000000000000000\");\n\n// Same bytes can be read differently, for example: Option<u64>\nlet value: Option<u64> = bcs.peel_option_u64();\n\nassert!(value.is_some(), 0);\nassert!(value.borrow() == &0, 1);\n\nlet remainder = bcs.into_remainder_bytes();\n\nassert!(remainder.length() == 0, 2);\n`\n```\n\nThere is a common practice to use multiple variables in a single `let`\n statement during decoding. It\nmakes code a little bit more readable and helps to avoid unnecessary copying of the data.\n\n```move`let mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// mind the order!!!\n// handy way to peel multiple values\nlet (bool_value, u8_value, u64_value) = (\n    bcs.peel_bool(),\n    bcs.peel_u8(),\n    bcs.peel_u64()\n);\n`\n```\n\n### Decoding Vectors\n\n\nWhile most of the primitive types have a dedicated decoding function, vectors need special handling,\nwhich depends on the type of the elements. For vectors, first you need to decode the length of the\nvector, and then decode each element in a loop.\n\n```move`let mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// bcs.peel_vec_length() peels the length of the vector :)\nlet mut len = bcs.peel_vec_length();\nlet mut vec = vector[];\n\n// then iterate depending on the data type\nwhile (len > 0) {\n    vec.push_back(bcs.peel_u64()); // or any other type\n    len = len - 1;\n};\n\nassert!(vec.length() == 1, 0);\n`\n```\n\nFor most common scenarios, `bcs`\n module provides a basic set of functions for decoding vectors:\n\n* `peel_vec_address(): vector<address>`\n\n\n* `peel_vec_bool(): vector<bool>`\n\n\n* `peel_vec_u8(): vector<u8>`\n\n\n* `peel_vec_u64(): vector<u64>`\n\n\n* `peel_vec_u128(): vector<u128>`\n\n\n* `peel_vec_vec_u8(): vector<vector<u8>>`\n - vector of byte vectors\n\n### Decoding Option\n\n\n\nOption is represented as a vector of either 0 or 1 element. To read an\noption, you would treat it like a vector and check its length (first byte - either 1 or 0).\n\n```move`let mut bcs = bcs::new(x\"00\");\nlet is_some = bcs.peel_bool();\n\nassert!(is_some == false, 0);\n\nlet mut bcs = bcs::new(x\"0101\");\nlet is_some = bcs.peel_bool();\nlet value = bcs.peel_u8();\n\nassert!(is_some == true, 1);\nassert!(value == 1, 2);\n`\n```\n\n\nIf you need to decode an option of a custom type, use the method in the code snippet above.\n\n\nThe most common scenarios, `bcs`\n module provides a basic set of functions for decoding Option's:\n\n* `peel_option_address(): Option<address>`\n\n\n* `peel_option_bool(): Option<bool>`\n\n\n* `peel_option_u8(): Option<u8>`\n\n\n* `peel_option_u64(): Option<u64>`\n\n\n* `peel_option_u128(): Option<u128>`\n\n\n### Decoding Structs\n\n\nStructs are decoded field by field, and there is no standard function to automatically decode bytes\ninto a Move struct, and it would have been a violation of the Move's type system. Instead, you need\nto decode each field manually.\n\n```move`// some bytes... \nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\nlet (age, is_active, name) = (\n    bcs.peel_u8(),\n    bcs.peel_bool(),\n    bcs.peel_vec_u8().to_string()\n);\n\nlet user = User { age, is_active, name };\n`\n```\n\n## Summary\n\n\nBinary Canonical Serialization is an efficient binary format for structured data, ensuring consistent serialization across platforms. The Sui Framework provides comprehensive tools for working with BCS, allowing extensive functionality through built-in functions.\n\n"}]}
