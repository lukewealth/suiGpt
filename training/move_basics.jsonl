{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is a module in the sui move language and how is it used?"}, {"role": "assistant", "content": "\n# Module\n\n\n\nModule is the base unit of code organization in Move. Modules are used to group and isolate code,\nand all of the members of the module are private to the module by default. In this section you will\nlearn how to define a module, how to declare its members and how to access them from other modules.\n\n## Module declaration\n\n\nModules are declared using the `module`\n keyword followed by the package address, module name and the\nmodule body inside the curly braces `{}`\n. The module name should be in `snake_case`\n - all lowercase\nletters with underscores between words. Modules names must be unique in the package.\n\nUsually, a single file in the `sources/`\n folder contains a single module. The file name should match\nthe module name - for example, a `donut_shop`\n module should be stored in the `donut_shop.move`\n file.\nYou can read more about coding conventions in the\nCoding Conventions section.\n\n```move`module book::my_module {\n    // module body\n}\n`\n```\n\nStructs, functions, constants and imports all part of the module:\n\n* [Structs](./struct.html)\n\n* [Functions](./function.html)\n\n* [Constants](./constants.html)\n\n* [Imports](./importing-modules.html)\n\n* [Struct Methods](./struct-methods.html)\n\n## Address / Named address\n\n\nModule address can be specified as both: an address literal (does not require the `@`\n prefix) or a\nnamed address specified in the Package Manifest. In the example below,\nboth are identical because there's a `book = \"0x0\"`\n record in the `[addresses]`\n section of the\n`Move.toml`\n.\n\n```move`module 0x0::address_literal { /* ... */ }\nmodule book::named_address { /* ... */ }\n`\n```\n\nAddresses section in the Move.toml:\n\n```move`# Move.toml\n[addresses]\nbook = \"0x0\"\n`\n```\n\n## Module members\n\n\nModule members are declared inside the module body. To illustrate that, let's define a simple module\nwith a struct, a function and a constant:\n\n```move`module book::my_module_with_members {\n    // import\n    use book::my_module;\n\n    // a constant\n    const CONST: u8 = 0;\n\n    // a struct\n    public struct Struct {}\n\n    // method alias\n    public use fun function as Struct.struct_fun;\n\n    // function\n    fun function(_: &Struct) { /* function body */ }\n}\n`\n```\n\n## Further reading\n\n\n* [Modules](/reference/modules.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How are comments used in the sui move language?"}, {"role": "assistant", "content": "\n# Comments\n\n\n\nComments are a way to add notes or document your code. They are ignored by the compiler and don't\nresult in the Move bytecode. You can use comments to explain what your code does, to add notes to\nyourself or other developers, to temporarily remove a part of your code, or to generate\ndocumentation. There are three types of comments in Move: line comment, block comment, and doc\ncomment.\n\n## Line comment\n\n\n```move`module book::comments_line {\n    fun some_function() {\n        // this is a comment line\n    }\n}\n`\n```\n\nYou can use double slash `//`\n to comment out the rest of the line. Everything after `//`\n will be\nignored by the compiler.\n\n```move`module book::comments_line_2 {\n    // let's add a note to everything!\n    fun some_function_with_numbers() {\n        let a = 10;\n        // let b = 10 this line is commented and won't be executed\n        let b = 5; // here comment is placed after code\n        a + b; // result is 15, not 10!\n    }\n}\n`\n```\n\n## Block comment\n\n\nBlock comments are used to comment out a block of code. They start with `/*`\n and end with `*/`\n.\nEverything between `/*`\n and `*/`\n will be ignored by the compiler. You can use block comments to\ncomment out a single line or multiple lines. You can even use them to comment out a part of a line.\n\n```move`module book::comments_block {\n    fun /* you can comment everywhere */ go_wild() {\n        /* here\n           there\n           everywhere */ let a = 10;\n        let b = /* even here */ 10; /* and again */\n        a + b;\n    }\n    /* you can use it to remove certain expressions or definitions\n    fun empty_commented_out() {\n\n    }\n    */\n}\n`\n```\n\nThis example is a bit extreme, but it shows how you can use block comments to comment out a part of\na line.\n\n## Doc comment\n\n\nDocumentation comments are special comments that are used to generate documentation for your code.\nThey are similar to block comments, but they start with three slashes `///`\n and are placed before\nthe definition of the item they document.\n\n```move`/// Module has documentation!\nmodule book::comments_doc {\n\n    /// This is a 0x0 address constant!\n    const AN_ADDRESS: address = @0x0;\n\n    /// This is a struct!\n    public struct AStruct {\n        /// This is a field of a struct!\n        a_field: u8,\n    }\n\n    /// This function does something!\n    /// And it's documented!\n    fun do_something() {}\n}\n`\n```\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are the primitive types in the sui move language?"}, {"role": "assistant", "content": "\n# Primitive Types\n\n\n\nFor simple values, Move has a number of built-in primitive types. They're the base that makes up all\nother types. The primitive types are:\n\n* [Booleans](#booleans)\n\n* [Unsigned Integers](#integers)\n\n* [Address](./address.html) - covered in the next section\n\nHowever, before we get to the types, let's first look at how to declare and assign variables in\nMove.\n\n## Variables and assignment\n\n\nVariables are declared using the `let`\n keyword. They are immutable by default, but can be made\nmutable using the `let mut`\n keyword. The syntax for the `let mut`\n statement is:\n\n```move`let <variable_name>[: <type>]  = <expression>;\nlet mut <variable_name>[: <type>] = <expression>;\n`\n```\n\nWhere:\n\n* `<variable_name>`\n - the name of the variable\n\n* `<type>`\n - the type of the variable, optional\n\n* `<expression>`\n - the value to be assigned to the variable\n\n```move`let x: bool = true;\nlet mut y: u8 = 42;\n`\n```\n\nA mutable variable can be reassigned using the `=`\n operator.\n\n```move`y = 43;\n`\n```\n\nVariables can also be shadowed by re-declaring.\n\n```move`let x: u8 = 42;\nlet x: u8 = 43;\n`\n```\n\n## Booleans\n\n\nThe `bool`\n type represents a boolean value - yes or no, true or false. It has two possible values:\n`true`\n and `false`\n which are keywords in Move. For booleans, there's no need to explicitly specify\nthe type - the compiler can infer it from the value.\n\n```move`let x = true;\nlet y = false;\n`\n```\n\nBooleans are often used to store flags and to control the flow of the program. Please, refer to the\nControl Flow section for more information.\n\n## Integer Types\n\n\nMove supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:\n\n* `u8`\n - 8-bit\n\n* `u16`\n - 16-bit\n\n* `u32`\n - 32-bit\n\n* `u64`\n - 64-bit\n\n* `u128`\n - 128-bit\n\n* `u256`\n - 256-bit\n\n```move`let x: u8 = 42;\nlet y: u16 = 42;\n// ...\nlet z: u256 = 42;\n`\n```\n\nUnlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer\nthe type from the value, usually defaulting to `u64`\n. However, sometimes the compiler is unable to\ninfer the type and will require an explicit type annotation. It can either be provided during\nassignment or by using a type suffix.\n\n```move`// Both are equivalent\nlet x: u8 = 42;\nlet x = 42u8;\n`\n```\n\n### Operations\n\n\nMove supports the standard arithmetic operations for integers: addition, subtraction,\nmultiplication, division, and remainder. The syntax for these operations is:\n\n| Syntax | Operation | Aborts If |\n|-----------------------------------|\n + | addition | Result is too large for the integer type |\n - | subtraction | Result is less than zero |\n * | multiplication | Result is too large for the integer type |\n % | modular division | The divisor is 0 |\n / | truncating division | The divisor is 0 |\n\n\n\nThe type of the operands must match, otherwise, the compiler will raise an error. The result of\nthe operation will be of the same type as the operands. To perform operations on different types,\nthe operands need to be cast to the same type.\n\n\n\n### Casting with as\n\n\nMove supports explicit casting between integer types. The syntax for it is:\n\n```move`(<expression> as <type>)\n`\n```\n\nNote, that it requires parentheses around the expression to prevent ambiguity.\n\n```move`let x: u8 = 42;\nlet y: u16 = (x as u16);\n`\n```\n\nA more complex example, preventing overflow:\n\n```move`let x: u8 = 255;\nlet y: u8 = 255;\nlet z: u16 = (x as u16) + ((y as u16) * 2);\n`\n```\n\n### Overflow\n\n\nMove does not support overflow / underflow, an operation that results in a value outside the range\nof the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.\n\n```move`let x = 255u8;\nlet y = 1u8;\n\n// This will raise an error\nlet z = x + y;\n`\n```\n\n## Further reading\n\n\n* [Bool](/reference/primitive-types/bool.html) in the Move Reference.\n\n* [Integer](/reference/primitive-types/integers.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are the address types in the sui move language?"}, {"role": "assistant", "content": "\n# Address Type\n\n\n\nTo represent addresses, Move uses a special type called `address`\n. It is\na 32 byte value that can be used to represent any address on the blockchain. Addresses are used in\ntwo syntax forms: hexadecimal addresses prefixed with `0x`\n and named addresses.\n\n```move`// address literal\nlet value: address = @0x1;\n\n// named address registered in Move.toml\nlet value = @std;\nlet other = @sui;\n`\n```\n\nAn address literal starts with the `@`\n symbol followed by a hexadecimal number or an identifier. The\nhexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the\nMove.toml file and replaced with the corresponding address by the\ncompiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.\n\n## Conversion\n\n\nSui Framework offers a set of helper functions to work with addresses. Given that the address type\nis a 32 byte value, it can be converted to a `u256`\n type and vice versa. It can also be converted to\nand from a `vector<u8>`\n type.\n\nExample: Convert an address to a `u256`\n type and back.\n\n```move`use sui::address;\n\nlet addr_as_u256: u256 = address::to_u256(@0x1);\nlet addr = address::from_u256(addr_as_u256);\n`\n```\n\nExample: Convert an address to a `vector<u8>`\n type and back.\n\n```move`use sui::address;\n\nlet addr_as_u8: vector<u8> = address::to_bytes(@0x1);\nlet addr = address::from_bytes(addr_as_u8);\n`\n```\n\nExample: Convert an address into a string.\n\n```move`use sui::address;\nuse std::string::String;\n\nlet addr_as_string: String = address::to_string(@0x1);\n`\n```\n\n## Further reading\n\n\n* [Address](/reference/primitive-types/address.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are expressions and how do i use them in the sui move language?"}, {"role": "assistant", "content": "\n# Expression\n\n\nIn programming languages expression is a unit of code which returns a value, in Move, almost\neverything is an expression, - with the sole exception of `let`\n statement which is a declaration. In\nthis section, we cover the types of expressions and introduce the concept of scope.\n\n\nExpressions are sequenced with semicolons `;`\n. If there's \"no expression\" after the semicolon, the\ncompiler will insert a unit `()`\n - an empty expression.\n\n\n## Literals\n\n\nIn the Primitive Types section, we introduced the basic types of Move. And\nto illustrate them, we used literals. A literal is a notation for representing a fixed value in the\nsource code. Literals are used to initialize variables and to pass arguments to functions. Move has\nthe following literals:\n\n* `true`\n and `false`\n for boolean values\n\n* `0`\n, `1`\n, `123123`\n or other numeric for integer values\n\n* `0x0`\n, `0x1`\n, `0x123`\n or other hexadecimal for integer values\n\n* `b\"bytes_vector\"`\n for byte vector values\n\n* `x\"0A\"`\n HEX literal for byte values\n\n```move`let b = true;     // true is a literal\nlet n = 1000;     // 1000 is a literal\nlet h = 0x0A;     // 0x0A is a literal\nlet v = b\"hello\"; // b'hello' is a byte vector literal\nlet x = x\"0A\";    // x'0A' is a byte vector literal\nlet c = vector[1, 2, 3]; // vector[] is a vector literal\n`\n```\n\n## Operators\n\n\nArithmetic, logical, and bitwise operators are used to perform operations on values. The result of\nan operation is a value, so operators are also expressions.\n\n```move`let sum = 1 + 2;   // 1 + 2 is an expression\nlet sum = (1 + 2); // the same expression with parentheses\nlet is_true = true && false; // true && false is an expression\nlet is_true = (true && false); // the same expression with parentheses\n`\n```\n\n## Blocks\n\n\nA block is a sequence of statements and expressions, and it returns the value of the last expression\nin the block. A block is written as a pair of curly braces `{}`\n. A block is an expression, so it can\nbe used anywhere an expression is expected.\n\n```move`// block with an empty expression, however, the compiler will\n// insert an empty expression automatically: `let none = { () }`\n// let none = {};\n\n// block with let statements and an expression.\nlet sum = {\n    let a = 1;\n    let b = 2;\n    a + b // last expression is the value of the block\n};\n\n// block is an expression, so it can be used in an expression and\n// doesn't have to be assigned to a variable.\n{\n    let a = 1;\n    let b = 2;\n    a + b; // not returned - semicolon.\n    // compiler automatically inserts an empty expression `()`\n};\n`\n```\n\n## Function Calls\n\n\nWe go into detail about functions in the Functions section. However, we already\nused function calls in the previous sections, so it's worth mentioning them here. A function call is\nan expression that calls a function and returns the value of the last expression in the function\nbody.\n\n```move`fun add(a: u8, b: u8): u8 {\n    a + b\n}\n\n#[test]\nfun some_other() {\n    let sum = add(1, 2); // add(1, 2) is an expression with type u8\n}\n`\n```\n\n## Control Flow Expressions\n\n\nControl flow expressions are used to control the flow of the program. They are also expressions, so\nthey return a value. We cover control flow expressions in the Control Flow\nsection. Here's a very brief overview:\n\n```move`// if is an expression, so it returns a value; if there are 2 branches,\n// the types of the branches must match.\nif (bool_expr) expr1 else expr2;\n\n// while is an expression, but it returns `()`.\nwhile (bool_expr) { expr; };\n\n// loop is an expression, but returns `()` as well.\nloop { expr; break };\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How do i use custom types in the sui move language?"}, {"role": "assistant", "content": "\n# Custom Types with Struct\n\n\nMove's type system shines when it comes to defining custom types. User defined types can be custom\ntailored to the specific needs of the application. Not just on the data level, but also in its\nbehavior. In this section we introduce the struct definition and how to use it.\n\n## Struct\n\n\nTo define a custom type, you can use the `struct`\n keyword followed by the name of the type. After\nthe name, you can define the fields of the struct. Each field is defined with the\n`field_name: field_type`\n syntax. Field definitions must be separated by commas. The fields can be of\nany type, including other structs.\n\n\nMove does not support recursive structs, meaning a struct cannot contain itself as a field.\n\n\n```move`/// A struct representing an artist.\npublic struct Artist {\n    /// The name of the artist.\n    name: String,\n}\n\n/// A struct representing a music record.\npublic struct Record {\n    /// The title of the record.\n    title: String,\n    /// The artist of the record. Uses the `Artist` type.\n    artist: Artist,\n    /// The year the record was released.\n    year: u16,\n    /// Whether the record is a debut album.\n    is_debut: bool,\n    /// The edition of the record.\n    edition: Option<u16>,\n}\n`\n```\n\nIn the example above, we define a `Record`\n struct with five fields. The `title`\n field is of type\n`String`\n, the `artist`\n field is of type `Artist`\n, the `year`\n field is of type `u16`\n, the `is_debut`\n\nfield is of type `bool`\n, and the `edition`\n field is of type `Option<u16>`\n. The `edition`\n field is of\ntype `Option<u16>`\n to represent that the edition is optional.\n\nStructs are private by default, meaning they cannot be imported and used outside of the module they\nare defined in. Their fields are also private and can't be accessed from outside the module. See\nvisibility for more information on different visibility modifiers.\n\n\nFields of a struct are private and can only be accessed by the module defining the struct. Reading\nand writing the fields of a struct in other modules is only possible if the module defining the\nstruct provides public functions to access the fields.\n\n\n## Create and use an instance\n\n\nWe described how struct definition works. Now let's see how to initialize a struct and use it. A\nstruct can be initialized using the `struct_name { field1: value1, field2: value2, ... }`\n syntax.\nThe fields can be initialized in any order, and all of the fields must be set.\n\n```move`let mut artist = Artist {\n    name: b\"The Beatles\".to_string()\n};\n`\n```\n\nIn the example above, we create an instance of the `Artist`\n struct and set the `name`\n field to a\nstring \"The Beatles\".\n\nTo access the fields of a struct, you can use the `.`\n operator followed by the field name.\n\n```move`// Access the `name` field of the `Artist` struct.\nlet artist_name = artist.name;\n\n// Access a field of the `Artist` struct.\nassert!(artist.name == string::utf8(b\"The Beatles\"), 0);\n\n// Mutate the `name` field of the `Artist` struct.\nartist.name = string::utf8(b\"Led Zeppelin\");\n\n// Check that the `name` field has been mutated.\nassert!(artist.name == string::utf8(b\"Led Zeppelin\"), 1);\n`\n```\n\nOnly module defining the struct can access its fields (both mutably and immutably). So the above\ncode should be in the same module as the `Artist`\n struct.\n\n\n## Unpacking a struct\n\n\nStructs are non-discardable by default, meaning that the initiated struct value must be used: either\nstored or unpacked. Unpacking a struct means deconstructing it into its fields. This is done using\nthe `let`\n keyword followed by the struct name and the field names.\n\n```move`// Unpack the `Artist` struct and create a new variable `name`\n// with the value of the `name` field.\nlet Artist { name } = artist;\n`\n```\n\nIn the example above we unpack the `Artist`\n struct and create a new variable `name`\n with the value\nof the `name`\n field. Because the variable is not used, the compiler will raise a warning. To\nsuppress the warning, you can use the underscore `_`\n to indicate that the variable is intentionally\nunused.\n\n```move`// Unpack the `Artist` struct and ignore the `name` field.\nlet Artist { name: _ } = artist;\n`\n```\n\n## Further reading\n\n\n* [Structs](/reference/structs.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are abilites in the sui move language?"}, {"role": "assistant", "content": "\n# Abilities: Introduction\n\n\nMove has a unique type system which allows customizing type abilities.\nIn the previous section, we introduced the `struct`\n definition and how to use it.\nHowever, the instances of the `Artist`\n and `Record`\n structs had to be unpacked for the code to\ncompile. This is default behavior of a struct without abilities.\n\n\nThroughout the book you will see chapters with name `Ability: <name>`\n, where `<name>`\n is the name\nof the ability. These chapters will cover the ability in detail, how it works, and how to use it\nin Move.\n\n\n## What are Abilities?\n\n\nAbilities are a way to allow certain behaviors for a type. They are a part of the struct declaration\nand define which behaviours are allowed for the instances of the struct.\n\n## Abilities syntax\n\n\nAbilities are set in the struct definition using the `has`\n keyword followed by a list of abilities.\nThe abilities are separated by commas. Move supports 4 abilities: `copy`\n, `drop`\n, `key`\n, and\n`store`\n, each of them is used to define a specific behaviour for the struct instances.\n\n```move`/// This struct has the `copy` and `drop` abilities.\nstruct VeryAble has copy, drop {\n    // field: Type1,\n    // field2: Type2,\n    // ...\n}\n`\n```\n\n## Overview\n\n\nA quick overview of the abilities:\n\n\nAll of the built-in types, except references, have `copy`\n, `drop`\n and `store`\n abilities.\nReferences have `copy`\n and `drop`\n.\n\n\n* `copy`\n - allows the struct to be *copied*\n. Explained in the [Ability: Copy](./copy-ability.html)\nchapter.\n\n* `drop`\n - allows the struct to be *dropped*\n or *discarded*\n. Explained in the\n[Ability: Drop](./drop-ability.html) chapter.\n\n* `key`\n - allows the struct to be used as a *key*\n in a storage. Explained in the\n[Ability: Key](./../storage/key-ability.html) chapter.\n\n* `store`\n - allows the struct to be *stored*\n in structs with the *key*\n ability. Explained in the\n[Ability: Store](./../storage/store-ability.html) chapter.\n\nWhile it is important to mention them here, we will go in detail about each ability in the following\nchapters and give a proper context on how to use them.\n\n## No abilities\n\n\nA struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a\nstruct a Hot Potato. It is a joke, but it is also a good way to remember that a struct without\nabilities is like a hot potato - it can only be passed around and requires special handling. Hot\nPotato is one of the most powerful patterns in Move, we go in detail about it in the\nHot Potato chapter.\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is the drop ability in the sui move language?"}, {"role": "assistant", "content": "\n# Abilities: Drop\n\n\n\n\n\n## Drop ability\n\n\nThe `drop`\n ability - the simplest of them - allows the instance of a struct to be ignored or\ndiscarded. In many programming languages this behavior is considered default. However, in Move, a\nstruct without the `drop`\n ability is not allowed to be ignored. This is a safety feature of the Move\nlanguage, which ensures that all assets are properly handled. An attempt to ignore a struct without\nthe `drop`\n ability will result in a compilation error.\n\n```move`module book::drop_ability {\n\n    /// This struct has the `drop` ability.\n    public struct IgnoreMe has drop {\n        a: u8,\n        b: u8,\n    }\n\n    /// This struct does not have the `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    // Create an instance of the `IgnoreMe` struct and ignore it.\n    // Even though we constructed the instance, we don't need to unpack it.\n    fun test_ignore() {\n        let no_drop = NoDrop {};\n        let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack\n\n        // The value must be unpacked for the code to compile.\n        let NoDrop {} = no_drop; // OK\n    }\n}\n`\n```\n\nThe `drop`\n ability is often used on custom collection types to eliminate the need for special\nhandling of the collection when it is no longer needed. For example, a `vector`\n type has the `drop`\n\nability, which allows the vector to be ignored when it is no longer needed. However, the biggest\nfeature of Move's type system is the ability to not have `drop`\n. This ensures that the assets are\nproperly handled and not ignored.\n\nA struct with a single `drop`\n ability is called a Witness. We explain the concept of a Witness\nin the\nWitness and Abstract Implementation\nsection.\n\n## Types with the drop Ability\n\n\nAll native types in Move have the `drop`\n ability. This includes:\n\n* [bool](./../move-basics/primitive-types.html#booleans)\n\n* [unsigned integers](./../move-basics/primitive-types.html#integers)\n\n* [vector](./../move-basics/vector.html)\n\n* [address](./../move-basics/address.html)\n\nAll of the types defined in the standard library have the `drop`\n ability as well. This includes:\n\n* [Option](./../move-basics/option.html)\n\n* [String](./../move-basics/string.html)\n\n* [TypeName](./../move-basics/type-reflection.html#typename)\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How do i import modules in the sui move language?"}, {"role": "assistant", "content": "\n# Importing Modules\n\n\n\n\nMove achieves high modularity and code reuse by allowing module imports. Modules within the same\npackage can import each other, and a new package can depend on already existing packages and use\ntheir modules too. This section will cover the basics of importing modules and how to use them in\nyour own code.\n\n## Importing a Module\n\n\nModules defined in the same package can import each other. The `use`\n keyword is followed by the\nmodule path, which consists of the package address (or alias) and the module name separated by `::`\n.\n\n```move`// File: sources/module_one.move\nmodule book::module_one {\n    /// Struct defined in the same module.\n    public struct Character has drop {}\n\n    /// Simple function that creates a new `Character` instance.\n    public fun new(): Character { Character {} }\n}\n`\n```\n\nAnother module defined in the same package can import the first module using the `use`\n keyword.\n\n```move`// File: sources/module_two.move\nmodule book::module_two {\n    use book::module_one; // importing module_one from the same package\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_and_ignore() {\n        let _ = module_one::new();\n    }\n}\n`\n```\n\n## Importing Members\n\n\nYou can also import specific members from a module. This is useful when you only need a single\nfunction or a single type from a module. The syntax is the same as for importing a module, but you\nadd the member name after the module path.\n\n```move`module book::more_imports {\n    use book::module_one::new;       // imports the `new` function from the `module_one` module\n    use book::module_one::Character; // importing the `Character` struct from the `module_one` module\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n`\n```\n\n## Grouping Imports\n\n\nImports can be grouped into a single `use`\n statement using the curly braces `{}`\n. This is useful\nwhen you need to import multiple members from the same module. Move allows grouping imports from the\nsame module and from the same package.\n\n```move`module book::grouped_imports {\n    // imports the `new` function and the `Character` struct from\n    /// the `module_one` module\n    use book::module_one::{new, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n`\n```\n\nSingle function imports are less common in Move, since the function names can overlap and cause\nconfusion. A recommended practice is to import the entire module and use the module path to access\nthe function. Types have unique names and should be imported individually.\n\nTo import members and the module itself in the group import, you can use the `Self`\n keyword. The\n`Self`\n keyword refers to the module itself and can be used to import the module and its members.\n\n```move`module book::self_imports {\n    // imports the `Character` struct, and the `module_one` module\n    use book::module_one::{Self, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        module_one::new()\n    }\n}\n`\n```\n\n## Resolving Name Conflicts\n\n\nWhen importing multiple members from different modules, it is possible to have name conflicts. For\nexample, if you import two modules that both have a function with the same name, you will need to\nuse the module path to access the function. It is also possible to have modules with the same name\nin different packages. To resolve the conflict and avoid ambiguity, Move offers the `as`\n keyword to\nrename the imported member.\n\n```move`module book::conflict_resolution {\n    // `as` can be placed after any import, including group imports\n    use book::module_one::{Self as mod, Character as Char};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create(): Char {\n        mod::new()\n    }\n}\n`\n```\n\n## Adding an External Dependency\n\n\nEvery new package generated via the `sui`\n binary features a `Move.toml`\n file with a single\ndependency on the Sui Framework package. The Sui Framework depends on the Standard Library\npackage. And both of these packages are available in default configuration. Package dependencies are\ndefined in the Package Manifest as follows:\n\n```move`[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nLocal = { local = \"../my_other_package\" }\n`\n```\n\nThe `dependencies`\n section contains a list of package dependencies. The key is the name of the\npackage, and the value is either a git import table or a local path. The git import contains the URL\nof the package, the subdirectory where the package is located, and the revision of the package. The\nlocal path is a relative path to the package directory.\n\nIf a dependency is added to the `Move.toml`\n file, the compiler will automatically fetch (and later\nrefetch) the dependencies when building the package.\n\n## Importing a Module from Another Package\n\n\nNormally, packages define their addresses in the `[addresses]`\n section, so you can use the alias\ninstead of the address. For example, instead of `0x2::coin`\n module, you would use `sui::coin`\n. The\n`sui`\n alias is defined in the Sui Framework package. Similarly, the `std`\n alias is defined in the\nStandard Library package and can be used to access the standard library modules.\n\nTo import a module from another package, you use the `use`\n keyword followed by the module path. The\nmodule path consists of the package address (or alias) and the module name separated by `::`\n.\n\n```move`module book::imports {\n    use std::string; // std = 0x1, string is a module in the standard library\n    use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework\n}\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is the standard library in the sui move language?"}, {"role": "assistant", "content": "\n# Standard Library\n\n\n\nThe Move Standard Library provides functionality for native types and operations. It is a standard\ncollection of modules which do not interact with the storage, but provide basic tools for working\nand manipulating the data. It is the only dependency of the\nSui Framework, and is imported together with it.\n\n## Most Common Modules\n\n\nIn this book we go into detail about most of the modules in the Standard Library, however, it is\nalso helpful to give an overview of the features, so that you can get a sense of what is available\nand which module implements it.\n\n\n\n| Module | Description | Chapter |\n|-----------------------------------|\n [std::string](https://docs.sui.io/references/framework/move-stdlib/string) | Provides basic string operations | [String](./string.html) |\n [std::ascii](https://docs.sui.io/references/framework/move-stdlib/ascii) | Provides basic ASCII operations | [String](./string.html) |\n [std::option](https://docs.sui.io/references/framework/move-stdlib/option) | Implements an `Option<T>`\n | [Option](./option.html) |\n [std::vector](https://docs.sui.io/references/framework/move-stdlib/vector) | Native operations on the vector type | [Vector](./vector.html) |\n [std::bcs](https://docs.sui.io/references/framework/move-stdlib/bcs) | Contains the `bcs::to_bytes()`\n function | [BCS](../move-basics/bcs.html) |\n [std::address](https://docs.sui.io/references/framework/move-stdlib/address) | Contains a single `address::length`\n function | [Address](./address.html) |\n [std::type_name](https://docs.sui.io/references/framework/move-stdlib/type_name) | Allows runtime *type reflection*\n | [Type Reflection](./type-reflection.html) |\n std::hash | Hashing functions: `sha2_256`\n and `sha3_256`\n | [Cryptography and Hashing](../programmability/cryptography-and-hashing.html) |\n std::debug | Contains debugging functions, which are available in only in **test**\n mode | [Debugging](./debugging.html) |\n std::bit_vector | Provides operations on bit vectors | - |\n std::fixed_point32 | Provides the `FixedPoint32`\n type | - |\n\n\n\n## Exported Addresses\n\n\nStandard Library exports one named address - `std = 0x1`\n.\n\n```move`[addresses]\nstd = \"0x1\"\n`\n```\n\n## Implicit Imports\n\n\nSome of the modules are imported implicitly, and are available in the module without explicit `use`\n\nimport. For Standard Library, these modules and types are:\n\n* std::vector\n\n* std::option\n\n* std::option::Option\n\n## Importing std without Sui Framework\n\n\nThe Move Standard Library can be imported to the package directly. However, `std`\n alone is not\nenough to build a meaningful application, as it does not provide any storage capabilities, and can't\ninteract with the on-chain state.\n\n```move`MoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n`\n```\n\n## Source Code\n\n\nThe source code of the Move Standard Library is available in the\nSui repository.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are vectors in the sui move language?"}, {"role": "assistant", "content": "\n# Vector\n\n\nVectors are a native way to store collections of elements in Move. They are similar to arrays in\nother programming languages, but with a few differences. In this section, we introduce the `vector`\n\ntype and its operations.\n\n## Vector syntax\n\n\nThe `vector`\n type is defined using the `vector`\n keyword followed by the type of the elements in\nangle brackets. The type of the elements can be any valid Move type, including other vectors. Move\nhas a vector literal syntax that allows you to create vectors using the `vector`\n keyword followed by\nsquare brackets containing the elements (or no elements for an empty vector).\n\n```move`// An empty vector of bool elements.\nlet empty: vector<bool> = vector[];\n\n// A vector of u8 elements.\nlet v: vector<u8> = vector[10, 20, 30];\n\n// A vector of vector<u8> elements.\nlet vv: vector<vector<u8>> = vector[\n    vector[10, 20],\n    vector[30, 40]\n];\n`\n```\n\nThe `vector`\n type is a built-in type in Move, and does not need to be imported from a module.\nHowever, vector operations are defined in the `std::vector`\n module, and you need to import the\nmodule to use them.\n\n## Vector operations\n\n\nThe standard library provides methods to manipulate vectors. The following are some of the most\ncommonly used operations:\n\n* `push_back`\n: Adds an element to the end of the vector.\n\n* `pop_back`\n: Removes the last element from the vector.\n\n* `length`\n: Returns the number of elements in the vector.\n\n* `is_empty`\n: Returns true if the vector is empty.\n\n* `remove`\n: Removes an element at a given index.\n\n```move`let mut v = vector[10u8, 20, 30];\n\nassert!(v.length() == 3, 0);\nassert!(!v.is_empty(), 1);\n\nv.push_back(40);\nlet last_value = v.pop_back();\n\nassert!(last_value == 40, 2);\n`\n```\n\n## Destroying a Vector of non-droppable types\n\n\nA vector of non-droppable types cannot be discarded. If you define a vector of types without `drop`\n\nability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an\nexplicit call to `destroy_empty`\n function.\n\n```move`    /// A struct without `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    fun test_destroy_empty() {\n        // Initialize a vector of `NoDrop` elements.\n        let v = vector<NoDrop>[];\n\n        // While we know that `v` is empty, we still need to call\n        // the explicit `destroy_empty` function to discard the vector.\n        v.destroy_empty();\n    }\n`\n```\n\n## Further reading\n\n\n* [Vector](/reference/primitive-types/vector.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are options in the sui move language?"}, {"role": "assistant", "content": "\n# Option\n\n\nOption is a type that represents an optional value which may or may not exist. The concept of Option\nin Move is borrowed from Rust, and it is a very useful primitive in Move. `Option`\n is defined in the\nStandard Library, and is defined as follows:\n\nFile: move-stdlib/source/option.move\n\n```move`// File: move-stdlib/source/option.move\n/// Abstraction of a value that may or may not be present.\nstruct Option<Element> has copy, drop, store {\n    vec: vector<Element>\n}\n`\n```\n\n\nThe 'std::option' module is implicitly imported in every module, and you don't need to add an\nimport.\n\n\nThe `Option`\n is a generic type which takes a type parameter `Element`\n. It has a single field `vec`\n\nwhich is a `vector`\n of `Element`\n. Vector can have length 0 or 1, and this is used to represent the\npresence or absence of a value.\n\nOption type has two variants: `Some`\n and `None`\n. `Some`\n variant contains a value and `None`\n variant\nrepresents the absence of a value. The `Option`\n type is used to represent the absence of a value in\na type-safe way, and it is used to avoid the need for empty or `undefined`\n values.\n\n## In Practice\n\n\nTo showcase why Option type is necessary, let's look at an example. Consider an application which\ntakes a user input and stores it in a variable. Some fields are required, and some are optional. For\nexample, a user's middle name is optional. While we could use an empty string to represent the\nabsence of a middle name, it would require extra checks to differentiate between an empty string and\na missing middle name. Instead, we can use the `Option`\n type to represent the middle name.\n\n```move`module book::user_registry {\n    use std::string::String;\n\n    /// A struct representing a user record.\n    public struct User has drop {\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    }\n\n    /// Create a new `User` struct with the given fields.\n    public fun register(\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    ): User {\n        User { first_name, middle_name, last_name }\n    }\n}\n`\n```\n\nIn the example above, the `middle_name`\n field is of type `Option<String>`\n. This means that the\n`middle_name`\n field can either contain a `String`\n value or be empty. This makes it clear that the\nmiddle name is optional, and it avoids the need for extra checks to differentiate between an empty\nstring and a missing middle name.\n\n## Using Option\n\n\nTo use the `Option`\n type, you need to import the `std::option`\n module and use the `Option`\n type. You\ncan then create an `Option`\n value using the `some`\n or `none`\n methods.\n\n```move`// `option::some` creates an `Option` value with a value.\nlet mut opt = option::some(b\"Alice\");\n\n// `option.is_some()` returns true if option contains a value.\nassert!(opt.is_some(), 1);\n\n// internal value can be `borrow`ed and `borrow_mut`ed.\nassert!(opt.borrow() == &b\"Alice\", 0);\n\n// `option.extract` takes the value out of the option, leaving the option empty.\nlet inner = opt.extract();\n\n// `option.is_none()` returns true if option is None.\nassert!(opt.is_none(), 2);\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How are strings used in the sui move language?"}, {"role": "assistant", "content": "\n# String\n\n\nWhile Move does not have a built-in type to represent strings, it does have two standard\nimplementations for strings in the Standard Library. The `std::string`\n\nmodule defines a `String`\n type and methods for UTF-8 encoded strings, and the second module,\n`std::ascii`\n, provides an ASCII `String`\n type and its methods.\n\n\nSui execution environment automatically converts bytevector into `String`\n in transaction inputs.\nSo in many cases, String does not to be constructed in the\nTransaction Block.\n\n\n\n## Strings are bytes\n\n\nNo matter which type of string you use, it is important to know that strings are just bytes. The\nwrappers provided by the `string`\n and `ascii`\n modules are just that: wrappers. They do provide\nsafety checks and methods to work with strings, but at the end of the day, they are just vectors of\nbytes.\n\n```move`module book::custom_string {\n    /// Anyone can implement a custom string-like type by wrapping a vector.\n    public struct MyString {\n        bytes: vector<u8>,\n    }\n\n    /// Implement a `from_bytes` function to convert a vector of bytes to a string.\n    public fun from_bytes(bytes: vector<u8>): MyString {\n        MyString { bytes }\n    }\n\n    /// Implement a `bytes` function to convert a string to a vector of bytes.\n    public fun bytes(self: &MyString): &vector<u8> {\n        &self.bytes\n    }\n}\n`\n```\n\n## Working with UTF-8 Strings\n\n\nWhile there are two types of strings in the standard library, the `string`\n module should be\nconsidered the default. It has native implementations of many common operations, and hence is more\nefficient than the `ascii`\n module, which is fully implemented in Move.\n\n### Definition\n\n\nThe `String`\n type in the `std::string`\n module is defined as follows:\n\n```move`// File: move-stdlib/sources/string.move\n/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\npublic struct String has copy, drop, store {\n    bytes: vector<u8>,\n}\n`\n```\n\n### Creating a String\n\n\nTo create a new UTF-8 `String`\n instance, you can use the `string::utf8`\n method. The\nStandard Library provides an alias `.to_string()`\n on the `vector<u8>`\n for\nconvenience.\n\n```move`// the module is `std::string` and the type is `String`\nuse std::string::{Self, String};\n\n// strings are normally created using the `utf8` function\n// type declaration is not necessary, we put it here for clarity\nlet hello: String = string::utf8(b\"Hello\");\n\n// The `.to_string()` alias on the `vector<u8>` is more convenient\nlet hello = b\"Hello\".to_string();\n`\n```\n\n### Common Operations\n\n\nUTF8 String provides a number of methods to work with strings. The most common operations on strings\nare: concatenation, slicing, and getting the length. Additionally, for custom string operations, the\n`bytes()`\n method can be used to get the underlying byte vector.\n\n```move`let mut str = b\"Hello,\".to_string();\nlet another = b\" World!\".to_string();\n\n// append(String) adds the content to the end of the string\nstr.append(another);\n\n// `sub_string(start, end)` copies a slice of the string\nstr.sub_string(0, 5); // \"Hello\"\n\n// `length()` returns the number of bytes in the string\nstr.length(); // 12 (bytes)\n\n// methods can also be chained! Get a length of a substring\nstr.sub_string(0, 5).length(); // 5 (bytes)\n\n// whether the string is empty\nstr.is_empty(); // false\n\n// get the underlying byte vector for custom operations\nlet bytes: &vector<u8> = str.bytes();\n`\n```\n\n### Safe UTF-8 Operations\n\n\nThe default `utf8`\n method may abort if the bytes passed into it are not valid UTF-8. If you are not\nsure that the bytes you are passing are valid, you should use the `try_utf8`\n method instead. It\nreturns an `Option<String>`\n, which contains no value if the bytes are not valid UTF-8, and a string\notherwise.\n\n\nHint: the name that starts with `try_*`\n indicates that the function returns an Option with the\nexpected result or `none`\n if the operation fails. It is a common naming convention borrowed from\nRust.\n\n\n```move`// this is a valid UTF-8 string\nlet hello = b\"Hello\".try_to_string();\n\nassert!(hello.is_some(), 0); // abort if the value is not valid UTF-8\n\n// this is not a valid UTF-8 string\nlet invalid = b\"\\xFF\".try_to_string();\n\nassert!(invalid.is_none(), 0); // abort if the value is valid UTF-8\n`\n```\n\n### UTF-8 Limitations\n\n\nThe `string`\n module does not provide a way to access individual characters in a string. This is\nbecause UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to\n4 bytes. Similarly, the `length()`\n method returns the number of bytes in the string, not the number\nof characters.\n\nHowever, methods like `sub_string`\n and `insert`\n check character boundaries and will abort when the\nindex is in the middle of a character.\n\n## ASCII Strings\n\n\nThis section is coming soon!\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How are control flow statements used in the sui move language?"}, {"role": "assistant", "content": "\n# Control Flow\n\n\n\nControl flow statements are used to control the flow of execution in a program. They are used to\nmake decisions, to repeat a block of code, and to exit a block of code early. Move has the following\ncontrol flow statements (explained in detail below):\n\n* [`if`\n and `if-else`\n](#conditional-statements) - making decisions on whether to execute a block of\ncode\n\n* [`loop`\n and `while`\n loops](#repeating-statements-with-loops) - repeating a block of code\n\n* [`break`\n and `continue`\n statements](#exiting-a-loop-early) - exiting a loop early\n\n* [`return`\n](#return) statement - exiting a function early\n\n## Conditional Statements\n\n\nThe `if`\n expression is used to make decisions in a program. It evaluates a\nboolean expression and executes a block of code if the expression is\ntrue. Paired with `else`\n, it can execute a different block of code if the expression is false.\n\nThe syntax for the `if`\n expression is:\n\n```move`if (<bool_expression>) <expression>;\nif (<bool_expression>) <expression> else <expression>;\n`\n```\n\nJust like any other expression, `if`\n requires a semicolon, if there are other expressions following\nit. The `else`\n keyword is optional, except for the case when the resulting value is assigned to a\nvariable. We will cover this below.\n\n```move`    #[test]\n    fun test_if() {\n        let x = 5;\n\n        // `x > 0` is a boolean expression.\n        if (x > 0) {\n            std::debug::print(&b\"X is bigger than 0\".to_string())\n        };\n    }\n`\n```\n\nLet's see how we can use `if`\n and `else`\n to assign a value to a variable:\n\n```move`    #[test]\n    fun test_if_else() {\n        let x = 5;\n        let y = if (x > 0) {\n            1\n        } else {\n            0\n        };\n\n        assert!(y == 1, 0);\n    }\n`\n```\n\nHere we assign the value of the `if`\n expression to the variable `y`\n. If `x`\n is greater than 0, `y`\n\nwill be assigned the value 1, otherwise 0. The `else`\n block is necessary, because both branches must\nreturn a value of the same type. If we omit the `else`\n block, the compiler will throw an error.\n\n\nConditional expressions are one of the most important control flow statements in Move. They can use\neither user provided input or some already stored data to make decisions. In particular, they are\nused in the `assert!`\n macro to check if a condition is true, and if not, to\nabort execution. We will get to it very soon!\n\n## Repeating Statements with Loops\n\n\nLoops are used to execute a block of code multiple times. Move has two built-in types of loops:\n`loop`\n and `while`\n. In many cases they can be used interchangeably, but usually `while`\n is used when\nthe number of iterations is known in advance, and `loop`\n is used when the number of iterations is\nnot known in advance or there are multiple exit points.\n\nLoops are helpful when dealing with collections, such as vectors, or when we want to repeat a block\nof code until a certain condition is met. However, it is important to be careful with loops, as they\ncan lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.\n\n## The while loop\n\n\nThe `while`\n statement is used to execute a block of code as long as a boolean expression is true.\nJust like we've seen with `if`\n, the boolean expression is evaluated before each iteration of the\nloop. Just like conditional statements, the `while`\n loop is an expression and requires a semicolon\nif there are other expressions following it.\n\nThe syntax for the `while`\n loop is:\n\n```move`while (<bool_expression>) { <expressions>; };\n`\n```\n\nHere is an example of a `while`\n loop with a very simple condition:\n\n```move`    // This function iterates over the `x` variable until it reaches 10, the\n    // return value is the number of iterations it took to reach 10.\n    //\n    // If `x` is 0, then the function will return 10.\n    // If `x` is 5, then the function will return 5.\n    fun while_loop(mut x: u8): u8 {\n        let mut y = 0;\n\n        // This will loop until `x` is 10.\n        // And will never run if `x` is 10 or more.\n        while (x < 10) {\n            y = y + 1;\n            x = x + 1;\n        };\n\n        y\n    }\n\n    #[test]\n    fun test_while() {\n        assert!(while_loop(0) == 10, 0); // 10 times\n        assert!(while_loop(5) == 5, 0);  // 5 times\n        assert!(while_loop(10) == 0, 0); // loop never executed\n    }\n`\n```\n\n## Infinite loop\n\n\nNow let's imagine a scenario where the boolean expression is always `true`\n. For example, if we\nliterally passed `true`\n to the `while`\n condition. As you might expect, this would create an infinite\nloop, and this is almost what the `loop`\n statement works like.\n\n```move`    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_while() {\n        let mut x = 0;\n\n        // This will loop forever.\n        while (true) {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n`\n```\n\nAn infinite `while`\n, or `while`\n without a condition, is a `loop`\n. The syntax for it is simple:\n\n```move`loop { <expressions>; };\n`\n```\n\nLet's rewrite the previous example using `loop`\n instead of `while`\n:\n\n```move`    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_loop() {\n        let mut x = 0;\n\n        // This will loop forever.\n        loop {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n`\n```\n\n\nInfinite loops on their own are not very useful in Move, since every operation in Move costs gas,\nand an infinite loop will lead to gas exhaustion. However, they can be used in combination with\n`break`\n and `continue`\n statements to create more complex loops.\n\n## Exiting a Loop Early\n\n\nAs we already mentioned, infinite loops are rather useless on their own. And that's where we\nintroduce the `break`\n and `continue`\n statements. They are used to exit a loop early, and to skip the\nrest of the current iteration, respectively.\n\nSyntax for the `break`\n statement is (without a semicolon):\n\n```move`break\n`\n```\n\nThe `break`\n statement is used to stop the execution of a loop and exit it early. It is often used in\ncombination with a conditional statement to exit the loop when a certain condition is met. To\nillustrate this point, let's turn the infinite `loop`\n from the previous example into something that\nlooks and behaves more like a `while`\n loop:\n\n```move`    #[test]\n    fun test_break_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 5.\n        loop {\n            x = x + 1;\n\n            // If `x` is 5, then exit the loop.\n            if (x == 5) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 5, 0);\n    }\n`\n```\n\nAlmost identical to the `while`\n loop, right? The `break`\n statement is used to exit the loop when `x`\n\nis 5. If we remove the `break`\n statement, the loop will run forever, just like the previous example.\n\n## Skipping an Iteration\n\n\nThe `continue`\n statement is used to skip the rest of the current iteration and start the next one.\nSimilarly to `break`\n, it is used in combination with a conditional statement to skip the rest of the\niteration when a certain condition is met.\n\nSyntax for the `continue`\n statement is (without a semicolon):\n\n```move`continue\n`\n```\n\nThe example below skips odd numbers and prints only even numbers from 0 to 10:\n\n```move`    #[test]\n    fun test_continue_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 10.\n        loop {\n            x = x + 1;\n\n            // If `x` is odd, then skip the rest of the iteration.\n            if (x % 2 == 1) {\n                continue // Skip the rest of the iteration.\n            };\n\n            std::debug::print(&x);\n\n            // If `x` is 10, then exit the loop.\n            if (x == 10) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 10, 0); // 10\n    }\n`\n```\n\n`break`\n and `continue`\n statements can be used in both `while`\n and `loop`\n loops.\n\n## Early Return\n\n\nThe `return`\n statement is used to exit a function early and return a value. It is\noften used in combination with a conditional statement to exit the function when a certain condition\nis met. The syntax for the `return`\n statement is:\n\n```move`return <expression>\n`\n```\n\nHere is an example of a function that returns a value when a certain condition is met:\n\n```move`    /// This function returns `true` if `x` is greater than 0 and not 5,\n    /// otherwise it returns `false`.\n    fun is_positive(x: u8): bool {\n        if (x == 5) {\n            return false\n        };\n\n        if (x > 0) {\n            return true\n        };\n\n        false\n    }\n\n    #[test]\n    fun test_return() {\n        assert!(is_positive(5) == false, 0);\n        assert!(is_positive(0) == false, 0);\n        assert!(is_positive(1) == true, 0);\n    }\n`\n```\n\nUnlike in other languages, the `return`\n statement is not required for the last expression in a\nfunction. The last expression in a function block is automatically returned. However, the `return`\n\nstatement is useful when we want to exit a function early if a certain condition is met.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are constants and how are they used in the sui move language?"}, {"role": "assistant", "content": "\n# Constants\n\n\n\nConstants are immutable values that are defined at the module level. They often serve as a way to\ngive names to static values that are used throughout a module. For example, if there's a default\nprice for a product, you might define a constant for it. Constants are stored in the module's\nbytecode, and each time they are used, the value is copied.\n\n```move`module book::shop_price {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n\n    /// The price of an item in the shop.\n    const ITEM_PRICE: u64 = 100;\n    /// The owner of the shop, an address.\n    const SHOP_OWNER: address = @0xa11ce;\n\n    /// An item sold in the shop.\n    public struct Item { /* ... */ }\n\n    /// Purchase an item from the shop.\n    public fun purchase(coin: Coin<SUI>): Item {\n        assert!(coin.value() == ITEM_PRICE, 0);\n\n        transfer::public_transfer(coin, SHOP_OWNER);\n\n        Item { /* ... */ }\n    }\n}\n`\n```\n\n## Naming Convention\n\n\nConstants must start with a capital letter - this is enforced at the compiler level. For constants\nused as a value, there's a convention to use uppercase letters and underscores to separate words.\nIt's a way to make constants stand out from other identifiers in the code. One exception is made for\nerror constants, which are written in ECamelCase.\n\n```move`/// Price of the item used at the shop.\nconst ITEM_PRICE: u64 = 100;\n\n/// Error constant.\nconst EItemNotFound: u64 = 1;\n`\n```\n\n## Constants are Immutable\n\n\nConstants can't be changed and assigned new values. They are part of the package bytecode, and\ninherently immutable.\n\n```move`module book::immutable_constants {\n    const ITEM_PRICE: u64 = 100;\n\n    // emits an error\n    fun change_price() {\n        ITEM_PRICE = 200;\n    }\n}\n`\n```\n\n## Using Config Pattern\n\n\nA common use case for an application is to define a set of constants that are used throughout the\ncodebase. But due to constants being private to the module, they can't be accessed from other\nmodules. One way to solve this is to define a \"config\" module that exports the constants.\n\n```move`module book::config {\n    const ITEM_PRICE: u64 = 100;\n    const TAX_RATE: u64 = 10;\n    const SHIPPING_COST: u64 = 5;\n\n    /// Returns the price of an item.\n    public fun item_price(): u64 { ITEM_PRICE }\n    /// Returns the tax rate.\n    public fun tax_rate(): u64 { TAX_RATE }\n    /// Returns the shipping cost.\n    public fun shipping_cost(): u64 { SHIPPING_COST }\n}\n`\n```\n\nThis way other modules can import and read the constants, and the update process is simplified. If\nthe constants need to be changed, only the config module needs to be updated during the package\nupgrade.\n\n## Links\n\n\n* [Constants](/reference/constants.html) in the Move Reference\n\n* [Coding conventions for constants](./../guides/coding-conventions.html#constant)\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `assert` and `abort` used for in the sui move language?"}, {"role": "assistant", "content": "\n# Assert and Abort\n\n\n\n\nA transaction can either succeed or fail. Successful execution applies all the changes made to\nobjects and on-chain data, and the transaction is committed to the blockchain. If a transaction\naborts, and changes are not applied. The `abort`\n keyword is used to abort a transaction and revert\nthe changes made so far.\n\n\nIt is important to note that there is no catch mechanism in Move. If a transaction aborts, the\nchanges made so far are reverted, and the transaction is considered failed.\n\n\n## Abort\n\n\nThe `abort`\n keyword is used to abort the execution of a transaction. It is used in combination with\nan abort code, which will be returned to the caller of the transaction. The abort code is an integer\nof type `u64`\n and can be any value.\n\n```move`let user_has_access = true;\n\n// abort with a predefined constant if `user_has_access` is false\nif (!user_has_access) {\n    abort 0\n};\n\n// there's an alternative syntax using parenthesis`\nif (user_has_access) {\n   abort(1)\n};\n`\n```\n\nThe code above will, of course, abort with abort code `1`\n.\n\n## assert!\n\n\nThe `assert!`\n macro is a built-in macro that can be used to assert a condition. If the condition is\nfalse, the transaction will abort with the given abort code. The `assert!`\n macro is a convenient way\nto abort a transaction if a condition is not met. The macro shortens the code otherwise written with\nan `if`\n expression + `abort`\n.\n\n```move`// aborts if `user_has_access` is `false` with abort code 0\nassert!(user_has_access, 0);\n\n// expands into:\nif (!user_has_access) {\n    abort 0\n};\n`\n```\n\n## Error constants\n\n\nTo make error codes more descriptive, it is a good practice to define error constants. Error\nconstants are defined as `const`\n declarations and are usually prefixed with `E`\n followed by a camel\ncase name. Error constants are no different from other constants and don't have special handling. So\ntheir addition is purely a practice for better code readability.\n\n```move`/// Error code for when the user has no access.\nconst ENoAccess: u64 = 0;\n/// Trying to access a field that does not exist.\nconst ENoField: u64 = 1;\n\n/// Updates a record.\npublic fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {\n    // asserts are way more readable now\n    assert!(user_has_access, ENoAccess);\n    assert!(field_exists, ENoField);\n\n    /* ... */\n}\n`\n```\n\n## Further reading\n\n\n* [Abort and Assert](/reference/abort-and-assert.html) in the Move Reference.\n\n* We suggest reading the [Better Error Handling](./../guides/better-error-handling.html) guide to\nlearn about best practices for error handling in Move.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How are functions declared and used in the sui move language?"}, {"role": "assistant", "content": "\n# Function\n\n\nFunctions are the building blocks of Move programs. They are called from\nuser transactions and from other functions and group executable\ncode into reusable units. Functions can take arguments and return a value. They are declared with\nthe `fun`\n keyword at the module level. Just like any other module member, by default they're private\nand can only be accessed from within the module.\n\n```move`module book::math {\n    /// Function takes two arguments of type `u64` and returns their sum.\n    /// The `public` visibility modifier makes the function accessible from\n    /// outside the module.\n    public fun add(a: u64, b: u64): u64 {\n        a + b\n    }\n\n    #[test]\n    fun test_add() {\n        let sum = add(1, 2);\n        assert!(sum == 3, 0);\n    }\n}\n`\n```\n\nIn this example, we define a function `add`\n that takes two arguments of type `u64`\n and returns their\nsum. The function is called from the `test_add`\n function, which is a test function located in the\nsame module. In the test we compare the result of the `add`\n function with the expected value and\nabort the execution if the result is different.\n\n## Function declaration\n\n\n\nThere's a convention to call functions in Move with the `snake_case`\n naming convention. This means\nthat the function name should be all lowercase with words separated by underscores. For example,\n`do_something`\n, `add`\n, `get_balance`\n, `is_authorized`\n, and so on.\n\n\nA function is declared with the `fun`\n keyword followed by the function name (a valid Move\nidentifier), a list of arguments in parentheses, and a return type. The function body is a block of\ncode that contains a sequence of statements and expressions. The last expression in the function\nbody is the return value of the function.\n\n```move`fun return_nothing() {\n    // empty expression, function returns `()`\n}\n`\n```\n\n## Accessing functions\n\n\nJust like any other module member, functions can be imported and accessed via a path. The path\nconsists of the module path and the function name separated by `::`\n. For example, if you have a\nfunction called `add`\n in the `math`\n module in the `book`\n package, the path to it will be\n`book::math::add`\n, or, if the module is imported, `math::add`\n.\n\n```move`module book::use_math {\n    use book::math;\n\n    fun call_add() {\n        // function is called via the path\n        let sum = math::add(1, 2);\n    }\n}\n`\n```\n\n## Multiple return values\n\n\nMove functions can return multiple values, which is useful when you need to return more than one\nvalue from a function. The return type of the function is a tuple of types. The return value is a\ntuple of expressions.\n\n```move`fun get_name_and_age(): (vector<u8>, u8) {\n    (b\"John\", 25)\n}\n`\n```\n\nResult of a function call with tuple return has to be unpacked into variables via `let (tuple)`\n\nsyntax:\n\n```move`// Tuple must be destructured to access its elements.\n// Name and age are declared as immutable variables.\nlet (name, age) = get_name_and_age();\nassert!(name == b\"John\", 0);\nassert!(age == 25, 0);\n`\n```\n\nIf any of the declared values need to be declared as mutable, the `mut`\n keyword is placed before the\nvariable name:\n\n```move`// declare name as mutable, age as immutable\nlet (mut name, age) = get_name_and_age();\n`\n```\n\nIf some of the arguments are not used, they can be ignored with the `_`\n symbol:\n\n```move`// ignore the name, only use the age\nlet (_, age) = get_name_and_age();\n`\n```\n\n## Further reading\n\n\n* [Functions](/reference/functions.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are struct methods in the sui move language?"}, {"role": "assistant", "content": "\n# Struct Methods\n\n\nMove Compiler supports receiver syntax, which allows defining methods which can be called on\ninstances of a struct. This is similar to the method syntax in other programming languages. It is a\nconvenient way to define functions which operate on the fields of a struct.\n\n## Method syntax\n\n\nIf the first argument of a function is a struct internal to the module, then the function can be\ncalled using the `.`\n operator. If the function uses a struct from another module, then method won't\nbe associated with the struct by default. In this case, the function can be called using the\nstandard function call syntax.\n\nWhen a module is imported, the methods are automatically associated with the struct.\n\n```move`module book::hero {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    /// A method which casts a spell, consuming mana.\n    public fun heal_spell(hero: &mut Hero) {\n        hero.health = hero.health + 10;\n        hero.mana = hero.mana - 10;\n    }\n\n    /// A method which returns the health of the hero.\n    public fun health(hero: &Hero): u8 { hero.health }\n\n    /// A method which returns the mana of the hero.\n    public fun mana(hero: &Hero): u8 { hero.mana }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_methods() {\n        let mut hero = new();\n        hero.heal_spell();\n\n        assert!(hero.health() == 110, 1);\n        assert!(hero.mana() == 90, 2);\n    }\n}\n`\n```\n\n## Method Aliases\n\n\nFor modules that define multiple structs and their methods, it is possible to define method aliases\nto avoid name conflicts, or to provide a better-named method for a struct.\n\nThe syntax for aliases is:\n\n```move`// for local method association\nuse fun function_path as Type.method_name;\n\n// exported alias\npublic use fun function_path as Type.method_name;\n`\n```\n\n\nPublic aliases are only allowed for structs defined in the same module. If a struct is defined in\nanother module, an alias can still be created but cannot be made public.\n\n\nIn the example below, we changed the `hero`\n module and added another type - `Villain`\n. Both `Hero`\n\nand `Villain`\n have similar field names and methods. And to avoid name conflicts, we prefixed methods\nwith `hero_`\n and `villain_`\n respectively. However, we can create aliases for these methods so that\nthey can be called on the instances of the structs without the prefix.\n\n```move`module book::hero_and_villain {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n    }\n\n    /// A struct representing a villain.\n    public struct Villain has drop {\n        health: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new_hero(): Hero { Hero { health: 100 } }\n\n    /// Create a new Villain.\n    public fun new_villain(): Villain { Villain { health: 100 } }\n\n    // Alias for the `hero_health` method. Will be imported automatically when\n    // the module is imported.\n    public use fun hero_health as Hero.health;\n\n    public fun hero_health(hero: &Hero): u8 { hero.health }\n\n    // Alias for the `villain_health` method. Will be imported automatically\n    // when the module is imported.\n    public use fun villain_health as Villain.health;\n\n    public fun villain_health(villain: &Villain): u8 { villain.health }\n\n    #[test]\n    // Test the methods of the `Hero` and `Villain` structs.\n    fun test_associated_methods() {\n        let hero = new_hero();\n        assert!(hero.health() == 100, 1);\n\n        let villain = new_villain();\n        assert!(villain.health() == 100, 3);\n    }\n}\n`\n```\n\nAs you can see, in the test function, we called the `health`\n method on the instances of `Hero`\n and\n`Villain`\n without the prefix. The compiler will automatically associate the methods with the\nstructs.\n\n## Aliasing an external module's method\n\n\nIt is also possible to associate a function defined in another module with a struct from the current\nmodule. Following the same approach, we can create an alias for the method defined in another\nmodule. Let's use the `bcs::to_bytes`\n method from the Standard Library and\nassociate it with the `Hero`\n struct. It will allow serializing the `Hero`\n struct to a vector of\nbytes.\n\n```move`// TODO: better example (external module...)\nmodule book::hero_to_bytes {\n    // Alias for the `bcs::to_bytes` method. Imported aliases should be defined\n    // in the top of the module.\n    // public use fun bcs::to_bytes as Hero.to_bytes;\n\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_hero_serialize() {\n        // let mut hero = new();\n        // let serialized = hero.to_bytes();\n        // assert!(serialized.length() == 3, 1);\n    }\n}\n`\n```\n\n## Further reading\n\n\n* [Method Syntax](/reference/method-syntax.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are visibility modifiers in the sui move language?"}, {"role": "assistant", "content": "\n# Visibility Modifiers\n\n\nEvery module member has a visibility. By default, all module members are private - meaning they\nare only accessible within the module they are defined in. However, you can add a visibility\nmodifier to make a module member public - visible outside the module, or public(package) -\nvisible in the modules within the same package, or entry - can be called from a transaction but\ncan't be called from other modules.\n\n## Internal Visibility\n\n\nA function or a struct defined in a module which has no visibility modifier is private to the\nmodule. It can't be called from other modules.\n\n```move`module book::internal_visibility {\n    // This function can be called from other functions in the same module\n    fun internal() { /* ... */ }\n\n    // Same module -> can call internal()\n    fun call_internal() {\n        internal();\n    }\n}\n`\n```\n\n\n\n```move`module book::try_calling_internal {\n    use book::internal_visibility;\n\n    // Different module -> can't call internal()\n    fun try_calling_internal() {\n        internal_visibility::internal();\n    }\n}\n`\n```\n\n## Public Visibility\n\n\nA struct or a function can be made public by adding the `public`\n keyword before the `fun`\n or\n`struct`\n keyword.\n\n```move`module book::public_visibility {\n    // This function can be called from other modules\n    public fun public() { /* ... */ }\n}\n`\n```\n\nA public function can be imported and called from other modules. The following code will compile:\n\n```move`module book::try_calling_public {\n    use book::public_visibility;\n\n    // Different module -> can call public()\n    fun try_calling_public() {\n        public_visibility::public();\n    }\n}\n`\n```\n\n## Package Visibility\n\n\nMove 2024 introduces the package visibility modifier. A function with package visibility can be\ncalled from any module within the same package. It can't be called from other packages.\n\n```move`module book::package_visibility {\n    public(package) fun package_only() { /* ... */ }\n}\n`\n```\n\nA package function can be called from any module within the same package:\n\n```move`module book::try_calling_package {\n    use book::package_visibility;\n\n    // Same package `book` -> can call package_only()\n    fun try_calling_package() {\n        package_visibility::package_only();\n    }\n}\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is `ownership` and `scope` in the sui move language?"}, {"role": "assistant", "content": "\n# Ownership and Scope\n\n\nEvery variable in Move has a scope and an owner. The scope is the range of code where the variable\nis valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the\nvariable is dropped. This is a fundamental concept in Move, and it is important to understand how it\nworks.\n\n\n## Ownership\n\n\nA variable defined in a function scope is owned by this scope. The runtime goes through the function\nscope and executes every expression and statement. Once the function scope end, the variables\ndefined in it are dropped or deallocated.\n\n```move`module book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function\n    } // a is dropped here\n\n    #[test]\n    fun test_owner() {\n        owner();\n        // a is not valid here\n    }\n}\n`\n```\n\nIn the example above, the variable `a`\n is owned by the `owner`\n function, and the variable `b`\n is\nowned by the `other`\n function. When each of these functions are called, the variables are defined,\nand when the function ends, the variables are discarded.\n\n## Returning a Value\n\n\nIf we changed the `owner`\n function to return the variable `a`\n, then the ownership of `a`\n would be\ntransferred to the caller of the function.\n\n```move`module book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a defined here\n        a // scope ends, a is returned\n    }\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        // a is valid here\n    } // a is dropped here\n}\n`\n```\n\n## Passing by Value\n\n\nAdditionally, if we passed the variable `a`\n to another function, the ownership of `a`\n would be\ntransferred to this function. When performing this operation, we move the value from one scope to\nanother. This is also called move semantics.\n\n```move`module book::ownership {\n    public fun owner(): u8 {\n        let a = 10;\n        a\n    } // a is returned\n\n    public fun take_ownership(v: u8) {\n        // v is owned by `take_ownership`\n    } // v is dropped here\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        take_ownership(a);\n        // a is not valid here\n    }\n}\n`\n```\n\n## Scopes with Blocks\n\n\nFunction has a main scope, and it can also have sub-scopes via the use of blocks. A block is a\nsequence of statements and expressions, and it has its own scope. Variables defined in a block are\nowned by this block, and when the block ends, the variables are dropped.\n\n```move`module book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function's scope\n        {\n            let b = 2; // b is owned by the block\n            {\n                let c = 3; // c is owned by the block\n            }; // c is dropped here\n        }; // b is dropped here\n        // a = b; // error: b is not valid here\n        // a = c; // error: c is not valid here\n    } // a is dropped here\n}\n`\n```\n\nHowever, shall we use the return value of a block, the ownership of the variable is transferred to\nthe caller of the block.\n\n```move`module book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a is owned by the `owner` function's scope\n        let b = {\n            let c = 2; // c is owned by the block\n            c // c is returned\n        }; // c is dropped here\n        a + b // both a and b are valid here\n    }\n}\n`\n```\n\n## Copyable Types\n\n\nSome types in Move are copyable, which means that they can be copied without transferring the\nownership. This is useful for types that are small and cheap to copy, such as integers and booleans.\nMove compiler will automatically copy these types when they are passed to a function or returned\nfrom a function, or when they're moved to a scope and then accessed in their original scope.\n\n## Further reading\n\n\n* [Local Variables and Scopes](/reference/variables.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is the copy ability in the sui move language?"}, {"role": "assistant", "content": "\n# Abilities: Copy\n\n\nIn Move, the copy ability on a type indicates that the instance or the value of the type can be\ncopied. While this behavior may feel very natural when working with numbers or other simple types,\nit is not the default for custom types in Move. This is because Move is designed to express digital\nassets and resources, and inability to copy is a key element of the resource model.\n\nHowever, Move type system allows you to define custom types with the copy ability.\n\n```move`public struct Copyable has copy {}\n`\n```\n\nIn the example above, we define a custom type `Copyable`\n with the copy ability. This means that\ninstances of `Copyable`\n can be copied, both implicitly and explicitly.\n\n```move`let a = Copyable {};\nlet b = a;   // `a` is copied to `b`\nlet c = *&b; // explicit copy via dereference operator\n\nlet Copyable {} = a; // doesn't have `drop`\nlet Copyable {} = b; // doesn't have `drop`\nlet Copyable {} = c; // doesn't have `drop`\n`\n```\n\nIn the example above, `a`\n is copied to `b`\n implicitly, and then explicitly copied to `c`\n using the\ndereference operator. If `Copyable`\n did not have the copy ability, the code would not compile, and\nthe Move compiler would raise an error.\n\n## Copying and Drop\n\n\nThe `copy`\n ability is closely related to `drop`\n ability. If a type has the\ncopy ability, very likely that it should have `drop`\n too. This is because the drop ability is\nrequired to clean up the resources when the instance is no longer needed. If a type has only copy,\nthen managing its instances gets more complicated, as the values cannot be ignored.\n\n```move`public struct Value has copy, drop {}\n`\n```\n\nAll of the primitive types in Move behave as if they have the copy and drop abilities. This\nmeans that they can be copied and dropped, and the Move compiler will handle the memory management\nfor them.\n\n## Types with the copy Ability\n\n\nAll native types in Move have the `copy`\n ability. This includes:\n\n* [bool](./../move-basics/primitive-types.html#booleans)\n\n* [unsigned integers](./../move-basics/primitive-types.html#integers)\n\n* [vector](./../move-basics/vector.html)\n\n* [address](./../move-basics/address.html)\n\nAll of the types defined in the standard library have the `copy`\n ability as well. This includes:\n\n* [Option](./../move-basics/option.html)\n\n* [String](./../move-basics/string.html)\n\n* [TypeName](./../move-basics/type-reflection.html#typename)\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `references` in the sui move language?"}, {"role": "assistant", "content": "\n# References\n\n\n\nIn the Ownership and Scope section, we explained that when a value is\npassed to a function, it is moved to the function's scope. This means that the function becomes\nthe owner of the value, and the original scope (owner) can no longer use it. This is an important\nconcept in Move, as it ensures that the value is not used in multiple places at the same time.\nHowever, there are use cases when we want to pass a value to a function but retain the ownership.\nThis is where references come into play.\n\nTo illustrate this, let's consider a simple example - an application for a metro (subway) pass. We\nwill look at 4 different scenarios:\n\n1. Card can be purchased at the kiosk for a fixed price\n2. Card can be shown to inspectors to prove that the passenger has a valid pass\n3. Card can be used at the turnstile to enter the metro, and spend a ride\n4. Card can be recycled once it's empty\n\n## Layout\n\n\nThe initial layout of the metro pass application is simple. We define the `Card`\n type and the `USES`\n\nconstant that represents the number of rides for a single card. We also add an\nerror constant for the case when the card is empty.\n\n```move`module book::metro_pass {\n    /// Error code for when the card is empty.\n    const ENoUses: u64 = 0;\n\n    /// Number of uses for a metro pass card.\n    const USES: u8 = 3;\n\n    /// A metro pass card\n    public struct Card { uses: u8 }\n\n    /// Purchase a metro pass card.\n    public fun purchase(/* pass a Coin */): Card {\n        Card { uses: USES }\n    }\n}\n`\n```\n\n\n## Reference\n\n\nReferences are a way to show a value to a function without giving up the ownership. In our case,\nwhen we show the Card to the inspector, we don't want to give up the ownership of it, and we don't\nallow them to spend the rides. We just want to allow reading the value of the Card and prove its\nownership.\n\nTo do so, in the function signature, we use the `&`\n symbol to indicate that we are passing a\nreference to the value, not the value itself.\n\n```move`    /// Show the metro pass card to the inspector.\n    public fun is_valid(card: &Card): bool {\n        card.uses > 0\n    }\n`\n```\n\nNow the function can't take the ownership of the card, and it can't spend the rides. But it can read\nits value. Worth noting, that a signature like this makes it impossible to call the function without\na Card at all. This is an important property which allows the\nCapability Pattern which we will cover in the next chapters.\n\n## Mutable Reference\n\n\nIn some cases, we want to allow the function to change the value of the Card. For example, when we\nuse the Card at the turnstile, we want to spend a ride. To implement it, we use the `&mut`\n keyword\nin the function signature.\n\n```move`    /// Use the metro pass card at the turnstile to enter the metro.\n    public fun enter_metro(card: &mut Card) {\n        assert!(card.uses > 0, ENoUses);\n        card.uses = card.uses - 1;\n    }\n`\n```\n\nAs you can see in the function body, the `&mut`\n reference allows mutating the value, and the\nfunction can spend the rides.\n\n## Passing by Value\n\n\nLastly, let's give an illustration of what happens when we pass the value itself to the function. In\nthis case, the function takes the ownership of the value, and the original scope can no longer use\nit. The owner of the Card can recycle it, and, hence, lose the ownership.\n\n```move`    /// Recycle the metro pass card.\n    public fun recycle(card: Card) {\n        assert!(card.uses == 0, ENoUses);\n        let Card { uses: _ } = card;\n    }\n`\n```\n\nIn the `recycle`\n function, the Card is taken by value and can be unpacked and destroyed. The\noriginal scope can't use it anymore.\n\n## Full Example\n\n\nTo illustrate the full flow of the application, let's put all the pieces together in a test.\n\n```move`    #[test]\n    fun test_card_2024() {\n        // declaring variable as mutable because we modify it\n        let mut card = purchase();\n\n        card.enter_metro(); // modify the card but don't move it\n        assert!(card.is_valid(), 0); // read the card!\n\n        card.enter_metro(); // modify the card but don't move it\n        card.enter_metro(); // modify the card but don't move it\n\n        card.recycle(); // move the card out of the scope\n    }\n`\n```\n\n\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `Generics` in the sui move language?"}, {"role": "assistant", "content": "\n# Generics\n\n\nGenerics are a way to define a type or function that can work with any type. This is useful when you\nwant to write a function which can be used with different types, or when you want to define a type\nthat can hold any other type. Generics are the foundation of many advanced features in Move, such as\ncollections, abstract implementations, and more.\n\n## In the Standard Library\n\n\nIn this chapter we already mentioned the vector type, which is a generic type that\ncan hold any other type. Another example of a generic type in the standard library is the\nOption type, which is used to represent a value that may or may not be present.\n\n## Generic Syntax\n\n\nTo define a generic type or function, a type signature needs to have a list of generic parameters\nenclosed in angle brackets (`<`\n and `>`\n). The generic parameters are separated by commas.\n\n```move`/// Container for any type `T`.\npublic struct Container<T> has drop {\n    value: T,\n}\n\n/// Function that creates a new `Container` with a generic value `T`.\npublic fun new<T>(value: T): Container<T> {\n    Container { value }\n}\n`\n```\n\nIn the example above, `Container`\n is a generic type with a single type parameter `T`\n, the `value`\n\nfield of the container stores the `T`\n. The `new`\n function is a generic function with a single type\nparameter `T`\n, and it returns a `Container`\n with the given value. Generic types must be initialed\nwith a concrete type, and generic functions must be called with a concrete type.\n\n```move`#[test]\nfun test_container() {\n    // these three lines are equivalent\n    let container: Container<u8> = new(10); // type inference\n    let container = new<u8>(10); // create a new `Container` with a `u8` value\n    let container = new(10u8);\n\n    assert!(container.value == 10, 0x0);\n\n    // Value can be ignored only if it has the `drop` ability.\n    let Container { value: _ } = container;\n}\n`\n```\n\nIn the test function `test_generic`\n we demonstrate three equivalent ways to create a new `Container`\n\nwith a `u8`\n value. Because numeric types need to be inferred, we specify the type of the number\nliteral.\n\n## Multiple Type Parameters\n\n\nYou can define a type or function with multiple type parameters. The type parameters are then\nseparated by commas.\n\n```move`/// A pair of values of any type `T` and `U`.\npublic struct Pair<T, U> {\n    first: T,\n    second: U,\n}\n\n/// Function that creates a new `Pair` with two generic values `T` and `U`.\npublic fun new_pair<T, U>(first: T, second: U): Pair<T, U> {\n    Pair { first, second }\n}\n`\n```\n\nIn the example above, `Pair`\n is a generic type with two type parameters `T`\n and `U`\n, and the\n`new_pair`\n function is a generic function with two type parameters `T`\n and `U`\n. The function returns\na `Pair`\n with the given values. The order of the type parameters is important, and it should match\nthe order of the type parameters in the type signature.\n\n```move`#[test]\nfun test_generic() {\n    // these three lines are equivalent\n    let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference\n    let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values\n    let pair_3 = new_pair(10u8, true);\n\n    assert!(pair_1.first == 10, 0x0);\n    assert!(pair_1.second, 0x0);\n\n    // Unpacking is identical.\n    let Pair { first: _, second: _ } = pair_1;\n    let Pair { first: _, second: _ } = pair_2;\n    let Pair { first: _, second: _ } = pair_3;\n\n}\n`\n```\n\nIf we added another instance where we swapped type parameters in the `new_pair`\n function, and tried\nto compare two types, we'd see that the type signatures are different, and cannot be compared.\n\n```move`#[test]\nfun test_swap_type_params() {\n    let pair1: Pair<u8, bool> = new_pair(10u8, true);\n    let pair2: Pair<bool, u8> = new_pair(true, 10u8);\n\n    // this line will not compile\n    // assert!(pair1 == pair2, 0x0);\n\n    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool\n    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8\n\n    assert!(pf1 == ps2, 0x0); // 10 == 10\n    assert!(ps1 == pf2, 0x0); // true == true\n}\n`\n```\n\nTypes for variables `pair1`\n and `pair2`\n are different, and the comparison will not compile.\n\n## Why Generics?\n\n\nIn the examples above we focused on instantiating generic types and calling generic functions to\ncreate instances of these types. However, the real power of generics is the ability to define shared\nbehavior for the base, generic type, and then use it independently of the concrete types. This is\nespecially useful when working with collections, abstract implementations, and other advanced\nfeatures in Move.\n\n```move`/// A user record with name, age, and some generic metadata\npublic struct User<T> {\n    name: String,\n    age: u8,\n    /// Varies depending on application.\n    metadata: T,\n}\n`\n```\n\nIn the example above, `User`\n is a generic type with a single type parameter `T`\n, with shared fields\n`name`\n and `age`\n, and the generic `metadata`\n field which can store any type. No matter what the\n`metadata`\n is, all of the instances of `User`\n will have the same fields and methods.\n\n```move`/// Updates the name of the user.\npublic fun update_name<T>(user: &mut User<T>, name: String) {\n    user.name = name;\n}\n\n/// Updates the age of the user.\npublic fun update_age<T>(user: &mut User<T>, age: u8) {\n    user.age = age;\n}\n`\n```\n\n## Phantom Type Parameters\n\n\nIn some cases, you may want to define a generic type with a type parameter that is not used in the\nfields or methods of the type. This is called a phantom type parameter. Phantom type parameters\nare useful when you want to define a type that can hold any other type, but you want to enforce some\nconstraints on the type parameter.\n\n```move`/// A generic type with a phantom type parameter.\npublic struct Coin<phantom T> {\n    value: u64\n}\n`\n```\n\nThe `Coin`\n type here does not contain any fields or methods that use the type parameter `T`\n. It is\nused to differentiate between different types of coins, and to enforce some constraints on the type\nparameter `T`\n.\n\n```move`public struct USD {}\npublic struct EUR {}\n\n#[test]\nfun test_phantom_type() {\n    let coin1: Coin<USD> = Coin { value: 10 };\n    let coin2: Coin<EUR> = Coin { value: 20 };\n\n    // Unpacking is identical because the phantom type parameter is not used.\n    let Coin { value: _ } = coin1;\n    let Coin { value: _ } = coin2;\n}\n`\n```\n\nIn the example above, we demonstrate how to create two different instances of `Coin`\n with different\nphantom type parameters `USD`\n and `EUR`\n. The type parameter `T`\n is not used in the fields or methods\nof the `Coin`\n type, but it is used to differentiate between different types of coins. It will make\nsure that the `USD`\n and `EUR`\n coins are not mixed up.\n\n## Constraints on Type Parameters\n\n\nType parameters can be constrained to have certain abilities. This is useful when you need the inner\ntype to allow certain behavior, such as copy or drop. The syntax for constraining a type\nparameter is `T: <ability> + <ability>`\n.\n\n```move`/// A generic type with a type parameter that has the `drop` ability.\npublic struct Droppable<T: drop> {\n    value: T,\n}\n\n/// A generic struct with a type parameter that has the `copy` and `drop` abilities.\npublic struct CopyableDroppable<T: copy + drop> {\n    value: T, // T must have the `copy` and `drop` abilities\n}\n`\n```\n\nMove Compiler will enforce that the type parameter `T`\n has the specified abilities. If the type\nparameter does not have the specified abilities, the code will not compile.\n\n\n```move`/// Type without any abilities.\npublic struct NoAbilities {}\n\n#[test]\nfun test_constraints() {\n    // Fails - `NoAbilities` does not have the `drop` ability\n    // let droppable = Droppable<NoAbilities> { value: 10 };\n\n    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities\n    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };\n}\n`\n```\n\n## Further Reading\n\n\n* [Generics](/reference/generics.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `type reflection` in the sui move language?"}, {"role": "assistant", "content": "\n# Type Reflection\n\n\nIn programming languages reflection is the ability of a program to examine and modify its own\nstructure and behavior. In Move, there's a limited form of reflection that allows you to inspect the\ntype of a value at runtime. This is useful when you need to store type information in a homogeneous\ncollection, or when you need to check if a type belongs to a package.\n\nType reflection is implemented in the Standard Library module\n`std::type_name`\n. Expressed very roughly, it gives a single function `get<T>()`\n which returns the\nname of the type `T`\n.\n\n## In practice\n\n\nThe module is pretty straightforward, and operations allowed on the result are limited to getting a\nstring representation and extracting the module and address of the type.\n\n```move`module book::type_reflection {\n    use std::ascii::String;\n    use std::type_name::{Self, TypeName};\n\n    /// A function that returns the name of the type `T` and its module and address.\n    public fun do_i_know_you<T>(): (String, String, String) {\n        let type_name: TypeName = type_name::get<T>();\n\n        // there's a way to borrow\n        let str: &String = type_name.borrow_string();\n\n        let module_name: String = type_name.get_module();\n        let address_str: String = type_name.get_address();\n\n        // and a way to consume the value\n        let str = type_name.into_string();\n\n        (str, module_name, address_str)\n    }\n\n    #[test_only]\n    public struct MyType {}\n\n    #[test]\n    fun test_type_reflection() {\n        let (type_name, module_name, _address_str) = do_i_know_you<MyType>();\n\n        //\n        assert!(module_name == b\"type_reflection\".to_ascii_string(), 1);\n    }\n}\n`\n```\n\n## Further reading\n\n\nType reflection is an important part of the language, and it is a crucial part of some of the more\nadvanced patterns.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `testing` in the sui move language?"}, {"role": "assistant", "content": "\n# Testing\n\n\nA crucial part of any software development, and even more - blockchain development, is testing.\nHere, we will cover the basics of testing in Move and how to write and organize tests for your Move\ncode.\n\n## The #[test] attribute\n\n\nTests in Move are functions marked with the `#[test]`\n attribute. This attribute tells the compiler\nthat the function is a test function, and it should be run when the tests are executed. Test\nfunctions are regular functions, but they must take no any arguments and have no return value. They\nare excluded from the bytecode, and are never published.\n\n```move`module book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n`\n```\n\n## Running Tests\n\n\nTo run tests, you can use the `sui move test`\n command. This command will first build the package in\nthe test mode and then run all the tests found in the package. During test mode, modules from both\n`sources/`\n and `tests/`\n directories are processed, and the tests are executed.\n\n```move`$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n`\n```\n\n\n## Test Fail Cases with #[expected_failure]\n\n\nTests for fail cases can be marked with `#[expected_failure]`\n. This attribute placed on a `#[test]`\n\nfunction tells the compiler that the test is expected to fail. This is useful when you want to test\nthat a function fails when a certain condition is met.\n\n\nThis attribute can only be placed on a `#[test]`\n function.\n\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test\nfails. If the test fails with a different abort code, the test will fail. If the execution did not\nabort, the test will also fail.\n\n```move`module book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n`\n```\n\nThe `abort_code`\n argument can use constants defined in the tests module as well as imported from\nother modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\n## Utilities with #[test_only]\n\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions\nor features. It simplifies the testing process and allows for more thorough testing. However, it is\nimportant to remember that these functions should not be included in the final package. This is\nwhere the `#[test_only]`\n attribute comes in handy.\n\n```move`module book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n`\n```\n\nFunctions marked with the `#[test_only]`\n will be available to the test environment, and to the other\nmodules if their visibility is set so.\n\n## Further Reading\n\n\n* [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `testing` in the sui move language?"}, {"role": "assistant", "content": "\n# Testing\n\n\nA crucial part of any software development, and even more - blockchain development, is testing.\nHere, we will cover the basics of testing in Move and how to write and organize tests for your Move\ncode.\n\n## The #[test] attribute\n\n\nTests in Move are functions marked with the `#[test]`\n attribute. This attribute tells the compiler\nthat the function is a test function, and it should be run when the tests are executed. Test\nfunctions are regular functions, but they must take no any arguments and have no return value. They\nare excluded from the bytecode, and are never published.\n\n```move`module book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n`\n```\n\n## Running Tests\n\n\nTo run tests, you can use the `sui move test`\n command. This command will first build the package in\nthe test mode and then run all the tests found in the package. During test mode, modules from both\n`sources/`\n and `tests/`\n directories are processed, and the tests are executed.\n\n```move`$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n`\n```\n\n\n## Test Fail Cases with #[expected_failure]\n\n\nTests for fail cases can be marked with `#[expected_failure]`\n. This attribute placed on a `#[test]`\n\nfunction tells the compiler that the test is expected to fail. This is useful when you want to test\nthat a function fails when a certain condition is met.\n\n\nThis attribute can only be placed on a `#[test]`\n function.\n\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test\nfails. If the test fails with a different abort code, the test will fail. If the execution did not\nabort, the test will also fail.\n\n```move`module book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n`\n```\n\nThe `abort_code`\n argument can use constants defined in the tests module as well as imported from\nother modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\n## Utilities with #[test_only]\n\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions\nor features. It simplifies the testing process and allows for more thorough testing. However, it is\nimportant to remember that these functions should not be included in the final package. This is\nwhere the `#[test_only]`\n attribute comes in handy.\n\n```move`module book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n`\n```\n\nFunctions marked with the `#[test_only]`\n will be available to the test environment, and to the other\nmodules if their visibility is set so.\n\n## Further Reading\n\n\n* [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `testing` in the sui move language?"}, {"role": "assistant", "content": "\n# Testing\n\n\nA crucial part of any software development, and even more - blockchain development, is testing.\nHere, we will cover the basics of testing in Move and how to write and organize tests for your Move\ncode.\n\n## The #[test] attribute\n\n\nTests in Move are functions marked with the `#[test]`\n attribute. This attribute tells the compiler\nthat the function is a test function, and it should be run when the tests are executed. Test\nfunctions are regular functions, but they must take no any arguments and have no return value. They\nare excluded from the bytecode, and are never published.\n\n```move`module book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n`\n```\n\n## Running Tests\n\n\nTo run tests, you can use the `sui move test`\n command. This command will first build the package in\nthe test mode and then run all the tests found in the package. During test mode, modules from both\n`sources/`\n and `tests/`\n directories are processed, and the tests are executed.\n\n```move`$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n`\n```\n\n\n## Test Fail Cases with #[expected_failure]\n\n\nTests for fail cases can be marked with `#[expected_failure]`\n. This attribute placed on a `#[test]`\n\nfunction tells the compiler that the test is expected to fail. This is useful when you want to test\nthat a function fails when a certain condition is met.\n\n\nThis attribute can only be placed on a `#[test]`\n function.\n\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test\nfails. If the test fails with a different abort code, the test will fail. If the execution did not\nabort, the test will also fail.\n\n```move`module book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n`\n```\n\nThe `abort_code`\n argument can use constants defined in the tests module as well as imported from\nother modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\n## Utilities with #[test_only]\n\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions\nor features. It simplifies the testing process and allows for more thorough testing. However, it is\nimportant to remember that these functions should not be included in the final package. This is\nwhere the `#[test_only]`\n attribute comes in handy.\n\n```move`module book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n`\n```\n\nFunctions marked with the `#[test_only]`\n will be available to the test environment, and to the other\nmodules if their visibility is set so.\n\n## Further Reading\n\n\n* [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `testing` in the sui move language?"}, {"role": "assistant", "content": "\n# Testing\n\n\nA crucial part of any software development, and even more - blockchain development, is testing.\nHere, we will cover the basics of testing in Move and how to write and organize tests for your Move\ncode.\n\n## The #[test] attribute\n\n\nTests in Move are functions marked with the `#[test]`\n attribute. This attribute tells the compiler\nthat the function is a test function, and it should be run when the tests are executed. Test\nfunctions are regular functions, but they must take no any arguments and have no return value. They\nare excluded from the bytecode, and are never published.\n\n```move`module book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n`\n```\n\n## Running Tests\n\n\nTo run tests, you can use the `sui move test`\n command. This command will first build the package in\nthe test mode and then run all the tests found in the package. During test mode, modules from both\n`sources/`\n and `tests/`\n directories are processed, and the tests are executed.\n\n```move`$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n`\n```\n\n\n## Test Fail Cases with #[expected_failure]\n\n\nTests for fail cases can be marked with `#[expected_failure]`\n. This attribute placed on a `#[test]`\n\nfunction tells the compiler that the test is expected to fail. This is useful when you want to test\nthat a function fails when a certain condition is met.\n\n\nThis attribute can only be placed on a `#[test]`\n function.\n\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test\nfails. If the test fails with a different abort code, the test will fail. If the execution did not\nabort, the test will also fail.\n\n```move`module book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n`\n```\n\nThe `abort_code`\n argument can use constants defined in the tests module as well as imported from\nother modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\n## Utilities with #[test_only]\n\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions\nor features. It simplifies the testing process and allows for more thorough testing. However, it is\nimportant to remember that these functions should not be included in the final package. This is\nwhere the `#[test_only]`\n attribute comes in handy.\n\n```move`module book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n`\n```\n\nFunctions marked with the `#[test_only]`\n will be available to the test environment, and to the other\nmodules if their visibility is set so.\n\n## Further Reading\n\n\n* [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `testing` in the sui move language?"}, {"role": "assistant", "content": "\n# Testing\n\n\nA crucial part of any software development, and even more - blockchain development, is testing.\nHere, we will cover the basics of testing in Move and how to write and organize tests for your Move\ncode.\n\n## The #[test] attribute\n\n\nTests in Move are functions marked with the `#[test]`\n attribute. This attribute tells the compiler\nthat the function is a test function, and it should be run when the tests are executed. Test\nfunctions are regular functions, but they must take no any arguments and have no return value. They\nare excluded from the bytecode, and are never published.\n\n```move`module book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n`\n```\n\n## Running Tests\n\n\nTo run tests, you can use the `sui move test`\n command. This command will first build the package in\nthe test mode and then run all the tests found in the package. During test mode, modules from both\n`sources/`\n and `tests/`\n directories are processed, and the tests are executed.\n\n```move`$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n`\n```\n\n\n## Test Fail Cases with #[expected_failure]\n\n\nTests for fail cases can be marked with `#[expected_failure]`\n. This attribute placed on a `#[test]`\n\nfunction tells the compiler that the test is expected to fail. This is useful when you want to test\nthat a function fails when a certain condition is met.\n\n\nThis attribute can only be placed on a `#[test]`\n function.\n\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test\nfails. If the test fails with a different abort code, the test will fail. If the execution did not\nabort, the test will also fail.\n\n```move`module book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n`\n```\n\nThe `abort_code`\n argument can use constants defined in the tests module as well as imported from\nother modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\n## Utilities with #[test_only]\n\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions\nor features. It simplifies the testing process and allows for more thorough testing. However, it is\nimportant to remember that these functions should not be included in the final package. This is\nwhere the `#[test_only]`\n attribute comes in handy.\n\n```move`module book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n`\n```\n\nFunctions marked with the `#[test_only]`\n will be available to the test environment, and to the other\nmodules if their visibility is set so.\n\n## Further Reading\n\n\n* [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `fast path and consensus` in the sui move language?"}, {"role": "assistant", "content": "\n# Fast Path & Consensus\n\n\nThe Object Model allows for variable transaction execution paths, depending on the object's\nownership type. The transaction execution path determines how the transaction is processed and\nvalidated by the network. In this section, we'll explore the different transaction execution paths\nin Sui and how they interact with the consensus mechanism.\n\n## Concurrency Challenge\n\n\nAt its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may\ntry to modify or access the same data simultaneously in a decentralized environment. This requires a\nsystem for sequencing and validating transactions to support the network's consistency. Sui\naddresses this challenge through a consensus mechanism, ensuring all nodes agree on the\ntransactions' sequence and state.\n\nConsider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same\nasset. The network must resolve this conflict to prevent double-spending, ensuring that at most one\ntransaction succeeds while the other is rightfully rejected.\n\n## Fast Path\n\n\nHowever, not all transactions require the same level of validation and consensus. For example, if\nAlice wants to transfer an object that she owns to Bob, the network can process this transaction\nwithout sequencing it with respect to all other transactions in the network, as only Alice has the\nauthority to access the object. This is known as the fast path execution, where transactions\naccessing account-owned objects are processed quickly without the need for extensive consensus. No\nconcurrent data access -> simpler challenge -> fast path.\n\nAnother ownership model that allows for fast path execution is the immutable state. Since\nimmutable objects cannot change, transactions involving them can be processed quickly without the\nneed to sequence them.\n\n## Consensus Path\n\n\nTransactions that do access shared state - on Sui it is represented with shared objects - require\nsequencing to ensure that the state is updated and consistented across all nodes. This is known as\nthe execution through consensus, where transactions accessing shared objects are subject to the\nagreement process to maintain network consistency.\n\n\n## Objects owned by Objects\n\n\nLastly, it is important to mention that objects owned by other objects are subject to the same rules\nas the parent object. If the parent object is shared, the child object is also transitively\nshared. If the parent object is immutable, the child object is also immutable.\n\n## Summary\n\n\n* **Fast Path:**\n Transactions involving account-owned objects or immutable shared state are\nprocessed quickly without the need for extensive consensus.\n\n* **Consensus Path:**\n Transactions involving shared objects require sequencing and consensus to\nensure network integrity.\n\n* **Objects owned by Objects:**\n Child objects inherit the ownership model of the parent object.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `key ability` in the sui move language?"}, {"role": "assistant", "content": "\n# The Key Ability\n\n\nIn the Basic Syntax chapter we already covered two out of four abilities -\nDrop and Copy. They affect the behaviour of the value in a\nscope and are not directly related to storage. It is time to cover the `key`\n ability, which allows\nthe struct to be stored.\n\nHistorically, the `key`\n ability was created to mark the type as a key in the storage. A type with\nthe `key`\n ability could be stored at top-level in the storage, and could be directly owned by an\naccount or address. With the introduction of the Object Model, the `key`\n ability\nnaturally became the defining ability for the object.\n\n\n## Object Definition\n\n\nA struct with the `key`\n ability is considered an object and can be used in the storage functions.\nThe Sui Verifier will require the first field of the struct to be named `id`\n and have the type\n`UID`\n.\n\n```move`public struct Object has key {\n    id: UID, // required\n    name: String,\n}\n\n/// Creates a new Object with a Unique ID\npublic fun new(name: String, ctx: &mut TxContext): Object {\n    Object {\n        id: object::new(ctx), // creates a new UID\n        name,\n    }\n}\n`\n```\n\nA struct with the `key`\n ability is still a struct, and can have any number of fields and associated\nfunctions. There is no special handling or syntax for packing, accessing or unpacking the struct.\n\nHowever, because the first field of an object struct must be of type `UID`\n - a non-copyable and\nnon-droppable type (we will get to it very soon!), the struct transitively cannot have `drop`\n and\n`copy`\n abilities. Thus, the object is non-discardable by design.\n\n\n## Types with the key Ability\n\n\nDue to the `UID`\n requirement for types with `key`\n, none of the native types in Move can have the\n`key`\n ability, nor can any of the Standard Library types.\nThe `key`\n ability is only present in the Sui Framework and\ncustom types.\n\n## Next Steps\n\n\nKey ability defines the object in Move, and objects are intended to be stored. In the next section\nwe present the `sui::transfer`\n module, which provides native storage functions for objects.\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `storage functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `capability` in the sui move language?"}, {"role": "assistant", "content": "\n# Pattern: Capability\n\n\nIn programming, a capability is a token that gives the owner the right to perform a specific\naction. It is a pattern that is used to control access to resources and operations. A simple example\nof a capability is a key to a door. If you have the key, you can open the door. If you don't have\nthe key, you can't open the door. A more practical example is an Admin Capability which allows the\nowner to perform administrative operations, which regular users cannot.\n\n## Capability is an Object\n\n\nIn the Sui Object Model, capabilities are represented as objects.\nAn owner of an object can pass this object to a function to prove that they have the right to\nperform a specific action. Due to strict typing, the function taking a capability as an argument can\nonly be called with the correct capability.\n\n\nThere's a convention to name capabilities with the `Cap`\n suffix, for example, `AdminCap`\n or\n`KioskOwnerCap`\n.\n\n\n```move`module book::capability {\n    use std::string::String;\n    use sui::event;\n\n    /// The capability granting the application admin the right to create new\n    /// accounts in the system.\n    public struct AdminCap has key, store { id: UID }\n\n    /// The user account in the system.\n    public struct Account has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// A simple `Ping` event with no data.\n    public struct Ping has copy, drop { by: ID }\n\n    /// Creates a new account in the system. Requires the `AdminCap` capability\n    /// to be passed as the first argument.\n    public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n        Account {\n            id: object::new(ctx),\n            name,\n        }\n    }\n\n    /// Account, and any other objects, can also be used as a Capability in the\n    /// application. For example, to emit an event.\n    public fun send_ping(acc: &Account) {\n        event::emit(Ping {\n            by: acc.id.to_inner()\n        })\n    }\n\n    /// Updates the account name. Can only be called by the `Account` owner.\n    public fun update(account: &mut Account, name: String) {\n        account.name = name;\n    }\n}\n`\n```\n\n## Using init for Admin Capability\n\n\nA very common practice is to create a single `AdminCap`\n object on package publish. This way, the\napplication can have a setup phase where the admin account prepares the state of the application.\n\n```move`module book::admin_cap {\n    /// The capability granting the admin privileges in the system.\n    /// Created only once in the `init` function.\n    public struct AdminCap has key { id: UID }\n\n    /// Create the AdminCap object on package publish and transfer it to the\n    /// package owner.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            AdminCap { id: object::new(ctx) },\n            ctx.sender()\n        )\n    }\n}\n`\n```\n\n## Address check vs Capability\n\n\nUtilizing objects as capabilities is a relatively new concept in blockchain programming. And in\nother smart-contract languages, authorization is often performed by checking the address of the\nsender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities\nfor better security, discoverability, and code organization.\n\nLet's look at how the `new`\n function that creates a user would look like if it was using the address\ncheck:\n\n```move`/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n`\n```\n\nAnd now, let's see how the same function would look like with the capability:\n\n```move`/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n`\n```\n\nUsing capabilities has several advantages over the address check:\n\n* Migration of admin rights is easier with capabilities due to them being objects. In case of\naddress, if the admin address changes, all the functions that check the address need to be\nupdated - hence, require a [package upgrade](./package-upgrades.html).\n\n* Function signatures are more descriptive with capabilities. It is clear that the `new`\n function\nrequires the `AdminCap`\n to be passed as an argument. And this function can't be called without it.\n\n* Object Capabilities don't require extra checks in the function body, and hence, decrease the\nchance of a developer mistake.\n\n* An owned Capability also serves in discovery. The owner of the AdminCap can see the object in\ntheir account (via a Wallet or Explorer), and know that they have the admin rights. This is less\ntransparent with the address check.\n\nHowever, the address approach has its own advantages. For example, if an address is multisig, and\ntransaction building gets more complex, it might be easier to check the address. Also, if there's a\ncentral object of the application that is used in every function, it can store the admin address,\nand this would simplify migration. The central object approach is also valuable for revokable\ncapabilities, where the admin can revoke the capability from the user.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `capability` in the sui move language?"}, {"role": "assistant", "content": "\n# Pattern: Capability\n\n\nIn programming, a capability is a token that gives the owner the right to perform a specific\naction. It is a pattern that is used to control access to resources and operations. A simple example\nof a capability is a key to a door. If you have the key, you can open the door. If you don't have\nthe key, you can't open the door. A more practical example is an Admin Capability which allows the\nowner to perform administrative operations, which regular users cannot.\n\n## Capability is an Object\n\n\nIn the Sui Object Model, capabilities are represented as objects.\nAn owner of an object can pass this object to a function to prove that they have the right to\nperform a specific action. Due to strict typing, the function taking a capability as an argument can\nonly be called with the correct capability.\n\n\nThere's a convention to name capabilities with the `Cap`\n suffix, for example, `AdminCap`\n or\n`KioskOwnerCap`\n.\n\n\n```move`module book::capability {\n    use std::string::String;\n    use sui::event;\n\n    /// The capability granting the application admin the right to create new\n    /// accounts in the system.\n    public struct AdminCap has key, store { id: UID }\n\n    /// The user account in the system.\n    public struct Account has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// A simple `Ping` event with no data.\n    public struct Ping has copy, drop { by: ID }\n\n    /// Creates a new account in the system. Requires the `AdminCap` capability\n    /// to be passed as the first argument.\n    public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n        Account {\n            id: object::new(ctx),\n            name,\n        }\n    }\n\n    /// Account, and any other objects, can also be used as a Capability in the\n    /// application. For example, to emit an event.\n    public fun send_ping(acc: &Account) {\n        event::emit(Ping {\n            by: acc.id.to_inner()\n        })\n    }\n\n    /// Updates the account name. Can only be called by the `Account` owner.\n    public fun update(account: &mut Account, name: String) {\n        account.name = name;\n    }\n}\n`\n```\n\n## Using init for Admin Capability\n\n\nA very common practice is to create a single `AdminCap`\n object on package publish. This way, the\napplication can have a setup phase where the admin account prepares the state of the application.\n\n```move`module book::admin_cap {\n    /// The capability granting the admin privileges in the system.\n    /// Created only once in the `init` function.\n    public struct AdminCap has key { id: UID }\n\n    /// Create the AdminCap object on package publish and transfer it to the\n    /// package owner.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            AdminCap { id: object::new(ctx) },\n            ctx.sender()\n        )\n    }\n}\n`\n```\n\n## Address check vs Capability\n\n\nUtilizing objects as capabilities is a relatively new concept in blockchain programming. And in\nother smart-contract languages, authorization is often performed by checking the address of the\nsender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities\nfor better security, discoverability, and code organization.\n\nLet's look at how the `new`\n function that creates a user would look like if it was using the address\ncheck:\n\n```move`/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n`\n```\n\nAnd now, let's see how the same function would look like with the capability:\n\n```move`/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n`\n```\n\nUsing capabilities has several advantages over the address check:\n\n* Migration of admin rights is easier with capabilities due to them being objects. In case of\naddress, if the admin address changes, all the functions that check the address need to be\nupdated - hence, require a [package upgrade](./package-upgrades.html).\n\n* Function signatures are more descriptive with capabilities. It is clear that the `new`\n function\nrequires the `AdminCap`\n to be passed as an argument. And this function can't be called without it.\n\n* Object Capabilities don't require extra checks in the function body, and hence, decrease the\nchance of a developer mistake.\n\n* An owned Capability also serves in discovery. The owner of the AdminCap can see the object in\ntheir account (via a Wallet or Explorer), and know that they have the admin rights. This is less\ntransparent with the address check.\n\nHowever, the address approach has its own advantages. For example, if an address is multisig, and\ntransaction building gets more complex, it might be easier to check the address. Also, if there's a\ncentral object of the application that is used in every function, it can store the admin address,\nand this would simplify migration. The central object approach is also valuable for revokable\ncapabilities, where the admin can revoke the capability from the user.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `collections` in the sui move language?"}, {"role": "assistant", "content": "\n# Collections\n\n\nCollection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The `vector`\n type has already been covered in the\nvector section, and in this chapter we will cover the vector-based\ncollection types offered by the Sui Framework.\n\n## Vector\n\n\nWhile we have previously covered the `vector`\n type in the\nvector section, it is worth going over it again in a new context. This\ntime we will cover the usage of the `vector`\n type in objects and how it can be used in an\napplication.\n\n```move`module book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n`\n```\n\n## VecSet\n\n\n`VecSet`\n is a collection type that stores a set of unique items. It is similar to a `vector`\n, but it\ndoes not allow duplicate items. This makes it useful for storing a collection of unique items, such\nas a list of unique IDs or addresses.\n\n```move`module book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n`\n```\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\n## VecMap\n\n\n`VecMap`\n is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`\n, but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data.\n\nKeys in a `VecMap`\n are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value.\n\n```move`module book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n`\n```\n\n## Limitations\n\n\nStandard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a `VecSet`\n to another `VecSet`\n may not yield the expected\nresults.\n\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result\n\n\n```move`let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n`\n```\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two `VecSet`\n instances may have different orders of elements. And the comparison will fail even\nif the two `VecSet`\n instances contain the same elements.\n\n## Summary\n\n\n* Vector is a native type that allows storing a list of items.\n\n* VecSet is built on top of vector and allows storing sets of unique items.\n\n* VecMap is used to store key-value pairs in a map-like structure.\n\n* Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists.\n\n## Next Steps\n\n\nIn the next section we will cover Dynamic Fields - an important primitive\nthat allows for Dynamic Collections - a way to store large collections\nof data in a more flexible, yet more expensive way.\n\n"}]}
