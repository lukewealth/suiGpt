{"messages": [{"role": "system","content": "SuiGPT is a chat agent that’s proficient in the Move smart contract language"},{"role": "user", "content": "Create a smart contract for a marketplace"},{"role": "assistant","content": "```move\n/*\n    This example features a marketplace where users can create shops and sell items. Every shop is a \n    global shared object that is managed by the shop owner, which is designated by the ownership of \n    the shop owner capability. The shop owner can add items to their shop, unlist items, and \n    withdraw the profit from their shop. Users can purchase items from shops and will receive a \n    purchased item receipt for each item purchased.\n\n    Shops: \n        A Shop is a global shared object that is managed by the shop owner. The shop object holds \n        items and the balance of SUI coins in the shop. \n    \n    Shop ownership: \n        Ownership of the Shop object is represented by holding the shop owner capability object. \n        The shop owner has the ability to add items to the shop, unlist items, and withdraw from \n        the shop. \n\n    Adding items to a shop: \n        The shop owner can add items to their shop with the add_item function.\n\n    Purchasing an item: \n        Anyone has the ability to purchase an item that is listed. When an item is purchased, the \n        buyer will receive a separate purchased item receipt for each item purchased. The purchased \n        item receipt is a object that is owned by the buyer and is used to represent a purchased \n        item.\n\n        The buyer must provide a payment coin for the item. The payment coin must be equal to or \n        greater than the price of the item. If the payment coin is greater than the price of the\n        item, the change will be left in the payment coin. \n\n        The profit from the sale of the item will be added to the shop balance. \n\n        The available supply of the item will be decreased by the quantity purchased. If the \n        available supply of the item is 0, the item will be unlisted.\n\n    Unlisting an item: \n        The shop owner can unlist an item from their shop with the unlist_item function. When an \n        item is unlisted, it will no longer be available for purchase.\n\n    Withdrawing from a shop: \n        The shop owner can withdraw SUI from their shop with the withdraw_from_shop function. The shop \n        owner can withdraw any amount from their shop that is equal to or below the total amount in \n        the shop. The amount withdrawn will be sent to the recipient address specified.    \n*/\nmodule example::marketplace {\n    //==============================================================================================\n    // Dependencies\n    //==============================================================================================\n    use sui::coin;\n    use sui::event;\n    use std::vector;\n    use sui::sui::SUI;\n    use sui::transfer;\n    use sui::url::{Self, Url};\n    use sui::object::{Self, UID, ID};\n    use sui::tx_context::{Self,TxContext};\n    use std::string::{Self, String};\n    use sui::balance::{Self, Balance};\n\n    #[test_only]\n    use sui::test_scenario;\n    #[test_only]\n    use sui::test_utils::assert_eq;\n\n    //==============================================================================================\n    // Constants - Add your constants here (if any)\n    //==============================================================================================\n\n    //==============================================================================================\n    // Error codes - DO NOT MODIFY\n    //==============================================================================================\n    const ENotShopOwner: u64 = 1;\n    const EInvalidWithdrawalAmount: u64 = 2;\n    const EInvalidQuantity: u64 = 3;\n    const EInsufficientPayment: u64 = 4;\n    const EInvalidItemId: u64 = 5;\n    const EInvalidPrice: u64 = 6;\n    const EInvalidSupply: u64 = 7;\n    const EItemIsNotListed: u64 = 8;\n\n    //==============================================================================================\n    // Module Structs - DO NOT MODIFY\n    //==============================================================================================\n\n    /*\n        The shop struct represents a shop in the marketplace. A shop is a global shared object that\n        is managed by the shop owner. The shop owner is designated by the ownership of the shop\n        owner capability. \n        @param id - The object id of the shop object.\n        @param shop_owner_cap - The object id of the shop owner capability.\n        @param balance - The balance of SUI coins in the shop.\n        @param items - The items in the shop.\n        @param item_count - The number of items in the shop. Including items that are not listed or \n            sold out.\n    */\n\tstruct Shop has key {\n\t\tid: UID,\n        shop_owner_cap: ID,\n\t\tbalance: Balance<SUI>,\n\t\titems: vector<Item>,\n        item_count: u64\n\t}\n\n    /*\n        The shop owner capability struct represents the ownership of a shop. The shop\n        owner capability is a object that is owned by the shop owner and is used to manage the shop.\n        @param id - The object id of the shop owner capability object.\n        @param shop - The object id of the shop object.\n    */\n    struct ShopOwnerCapability has key {\n        id: UID,\n        shop: ID,\n    }\n\n    /*\n        The item struct represents an item in a shop. An item is a product that can be purchased\n        from a shop.\n        @param id - The id of the item object. This is the index of the item in the shop's items\n            vector.\n        @param title - The title of the item.\n        @param description - The description of the item.\n        @param price - The price of the item (price per each quantity).\n        @param url - The url of item image.\n        @param listed - Whether the item is listed. If the item is not listed, it will not be \n            available for purchase.\n        @param category - The category of the item.\n        @param total_supply - The total supply of the item.\n        @param available - The available supply of the item. Will be less than or equal to the total\n            supply and will start at the total supply and decrease as items are purchased.\n    */\n    struct Item has store {\n\t\tid: u64,\n\t\ttitle: String,\n\t\tdescription: String,\n\t\tprice: u64,\n\t\turl: Url,\n        listed: bool,\n        category: u8,\n        total_supply: u64,\n        available: u64\n\t}\n\n    /*\n        The purchased item struct represents a purchased item receipt. A purchased item receipt is\n        a object that is owned by the buyer and is used to represent a purchased item.\n        @param id - The object id of the purchased item object.\n        @param shop_id - The object id of the shop object.\n        @param item_id - The id of the item object.\n    */\n    struct PurchasedItem has key {\n        id: UID,\n        shop_id: ID, \n        item_id: u64\n    }\n\n    //==============================================================================================\n    // Event structs - DO NOT MODIFY\n    //==============================================================================================\n\n    /*\n        Event to be emitted when a shop is created.\n        @param shop_id - The id of the shop object.\n        @param shop_owner_cap_id - The id of the shop owner capability object.\n    */\n    struct ShopCreated has copy, drop {\n        shop_id: ID,\n        shop_owner_cap_id: ID,\n    }\n\n    /*\n        Event to be emitted when an item is added to a shop.\n        @param item - The id of the item object.\n    */\n    struct ItemAdded has copy, drop {\n        shop_id: ID,\n        item: u64,\n    }\n\n    /*\n        Event to be emitted when an item is purchased.\n        @param item - The id of the item object.\n        @param quantity - The quantity of the item purchased.\n        @param buyer - The address of the buyer.\n    */\n    struct ItemPurchased has copy, drop {\n        shop_id: ID,\n        item_id: u64, \n        quantity: u64,\n        buyer: address,\n    }\n\n    /*\n        Event to be emitted when an item is unlisted.\n        @param item - The id of the item object.\n    */\n    struct ItemUnlisted has copy, drop {\n        shop_id: ID,\n        item_id: u64\n    }\n\n    /*\n        Event to be emitted when a shop owner withdraws from their shop.\n        @param shop_id - The id of the shop object.\n        @param amount - The amount withdrawn.\n        @param recipient - The address of the recipient of the withdrawal.\n    */\n    struct ShopWithdrawal has copy, drop {\n        shop_id: ID,\n        amount: u64,\n        recipient: address\n    }\n\n    //==============================================================================================\n    // Functions\n    //==============================================================================================\n\n\t/*\n        Creates a new shop for the recipient and emits a ShopCreated event.\n        @param recipient - The address of the recipient of the shop.\n        @param ctx - The transaction context.\n\t*/\n\tpublic fun create_shop(recipient: address, ctx: &mut TxContext) {\n\n        let _id =object::new(ctx);\n\n        let new_shop = Shop {\n            id: object::new(ctx),\n            shop_owner_cap:object::uid_to_inner(&_id) ,\n            balance: balance::zero<SUI>(),\n            items: vector::empty<Item>(),\n            item_count: 0\n\t    };\n        \n         let owner_cap =  ShopOwnerCapability {\n            id: object::new(ctx),\n            shop: object::uid_to_inner(&new_shop.id),\n        };\n\n        new_shop.shop_owner_cap = object::uid_to_inner(&owner_cap.id);\n        object::delete(_id);\n\n        event::emit(  ShopCreated {\n            shop_id:  object::uid_to_inner(&new_shop.id) ,\n            shop_owner_cap_id: object::uid_to_inner(&owner_cap.id),\n        });\n\n        transfer::share_object(new_shop);\n        transfer::transfer(owner_cap,recipient)\n\n\n\t}\n\n    /*\n        Adds a new item to the shop and emits an ItemAdded event. Abort if the shop owner capability\n        does not match the shop, if the price is not above 0, or if the supply is not above 0.\n        @param shop - The shop to add the item to.\n        @param shop_owner_cap - The shop owner capability of the shop.\n        @param title - The title of the item.\n        @param description - The description of the item.\n        @param url - The url of the item.\n        @param price - The price of the item.\n        @param supply - The initial supply of the item.\n        @param category - The category of the item.\n        @param ctx - The transaction context.\n    */\n    public fun add_item(\n        shop: &mut Shop,\n        shop_owner_cap: &ShopOwnerCapability, \n        title: vector<u8>,\n        description: vector<u8>,\n        url: vector<u8>,\n        price: u64, \n        supply: u64, \n        category: u8\n    ) {\n\n        let ShopOwnerCapability {id:_,shop:new_shop} = shop_owner_cap;\n        assert!(new_shop == object::uid_as_inner(&shop.id) ,ENotShopOwner);\n        assert!(price > 0,EInvalidPrice);\n        assert!(supply > 0,EInvalidSupply);\n\n        let item = Item  {\n            id: vector::length(&shop.items),\n            title:string::utf8(title),\n            description: string::utf8(description),\n            price,\n            url: url::new_unsafe_from_bytes(url),\n            listed: true,\n            category,\n            total_supply: supply,\n            available: supply\n        };\n\n\n        event::emit( ItemAdded {\n            shop_id: object::uid_to_inner(&shop.id),\n            item: item.id,\n        });\n        vector::push_back(&mut shop.items, item);\n    }\n\n    /*\n        Unlists an item from the shop and emits an ItemUnlisted event. Abort if the shop owner \n        capability does not match the shop or if the item id is invalid.\n        @param shop - The shop to unlist the item from.\n        @param shop_owner_cap - The shop owner capability of the shop.\n        @param item_id - The id of the item to unlist.\n    */\n    public fun unlist_item(\n        shop: &mut Shop,\n        shop_owner_cap: &ShopOwnerCapability,\n        item_id: u64\n    ) {\n        let ShopOwnerCapability {id:_ , shop:new_shop } = shop_owner_cap;\n        assert!(new_shop == object::uid_as_inner(&shop.id) ,ENotShopOwner);\n        assert_item_is_valid(&shop.items,item_id);\n\n        let item = vector::borrow_mut(&mut shop.items, item_id);\n        item.listed = false;\n\n        event::emit( ItemUnlisted  {\n            shop_id: object::uid_to_inner(&shop.id),\n            item_id,\n        });\n        \n        \n    }\n\n    /*\n        Purchases an item from the shop and emits an ItemPurchased event. Abort if the item id is\n        invalid, the payment coin is insufficient, if the item is unlisted, or the shop does not \n        have enough available supply. Emit an ItemUnlisted event if the last item(s) are purchased.\n        @param shop - The shop to purchase the item from.\n        @param item_id - The id of the item to purchase.\n        @param quantity - The quantity of the item to purchase.\n        @param recipient - The address of the recipient of the item.\n        @param payment_coin - The payment coin for the item.\n        @param ctx - The transaction context.\n    */\n    public fun purchase_item(\n        shop: &mut Shop, \n        item_id: u64,\n        quantity: u64,\n        recipient: address,\n        payment_coin: &mut coin::Coin<SUI>,\n        ctx: &mut TxContext\n    ) {\n\n        assert_item_is_valid(&shop.items,item_id);\n        let item = vector::borrow_mut(&mut shop.items, item_id);\n        assert!(item.listed,EItemIsNotListed);\n        assert!(item.available >= quantity ,EInvalidQuantity);\n\n       \n\n        \n\n        \n\n\n        let bal = coin::balance_mut(payment_coin);\n        assert!(balance::value<SUI>(bal) >= (item.price * quantity ),EInsufficientPayment);\n        let item_price = coin::take(bal, (item.price * quantity),ctx);\n        let item_bal = coin::balance_mut(&mut item_price);\n        balance::join(&mut shop.balance, balance::withdraw_all(item_bal));\n        coin::join(payment_coin, item_price);\n        item.available = item.available- quantity;\n        if (item.available == 0){\n            event::emit( ItemUnlisted {\n                shop_id: object::uid_to_inner(&shop.id),\n                item_id,\n\n            });\n            item.listed = false;\n        };\n\n        let i = 0;\n\n        while(i < quantity) {\n            let receipt = PurchasedItem  {\n                id: object::new(ctx),\n                shop_id: object::uid_to_inner(&shop.id), \n                item_id,\n            };\n            transfer::transfer(receipt,recipient);\n\n           i = i+1\n        };\n\n\n        event::emit( ItemPurchased {\n            shop_id: object::uid_to_inner(&shop.id),\n            item_id, \n            quantity,\n            buyer: recipient,\n        })\n\n    }\n\n    /*\n        Withdraws SUI from the shop to the recipient and emits a ShopWithdrawal event. Abort if the \n        shop owner capability does not match the shop or if the amount is invalid.\n        @param shop - The shop to withdraw from.\n        @param shop_owner_cap - The shop owner capability of the shop.\n        @param amount - The amount to withdraw.\n        @param recipient - The address of the recipient of the withdrawal.\n        @param ctx - The transaction context.\n    */\n    public fun withdraw_from_shop(\n        shop: &mut Shop,\n        shop_owner_cap: &ShopOwnerCapability,\n        amount: u64,\n        recipient: address,\n        ctx: &mut TxContext\n    ) {\n        let ShopOwnerCapability {id:_ , shop:new_shop } = shop_owner_cap;\n        assert!(new_shop == object::uid_as_inner(&shop.id) ,ENotShopOwner);\n        assert!(amount <= balance::value(&shop.balance),EInvalidWithdrawalAmount);\n\n        let coin_to_withdraw = coin::take(&mut shop.balance, amount,ctx);\n        transfer::public_transfer(coin_to_withdraw,recipient);\n\n\n        event::emit( ShopWithdrawal  {\n            shop_id: object::uid_to_inner(&shop.id),\n            amount,\n            recipient,\n        });\n        \n        \n    }\n\n       // Validation functions - Add your validation functions here (if any)\n    //==============================================================================================\n\n    fun assert_item_is_valid(shop: &vector<Item>,item_id:u64){\n        let item = vector::borrow(shop,item_id);\n        let (valid , _ ) = vector::index_of(shop, item);\n        assert!(valid,EInvalidItemId);\n    } \n}```"}]}
{"messages": [{"role": "system","content": "SuiGPT is a chat agent that’s proficient in the Move smart contract language"},{"role": "user", "content": "Create a smart contract around winning a lottery"},{"role": "assistant", "content": "/* \n    This quest features a NFT lottery where users can create their own lotteries with an NFT as the \n    prize. Each Lottery is a shared object in which the creator receives a `WithdrawalCapability` \n    which can be used to withdraw the ticket sales once the lottery has been run and a winner has \n    been announced.\n\n    Creating a lottery:\n        A lottery is created using the `create` entry function which requires the transfer of an NFT \n        and other parameters for the lottery, such as length in time, prize per ticket and the upper \n        range of ticket numbers. A `Lottery` shared object is created which defines the parameters \n        of the lottery, holds the NFT prize and collects ticket payments. The `WithdrawalCapability` \n        allows the owner of this object to withdraw from the corresponding `Lottery` once it has \n        successfully run.\n    \n    Buying a ticket:\n        Once a lottery is created, any user can purchase a ticket and will receive a `LotteryTicket` \n        as proof of this purchase. The user can select any number that they wish as long as the \n        number hasn't already been sold and is within the range specified for the lottery. Payment \n        is in SUI and must be greater or equal than the price per ticket for the lottery.\n\n    Running the lottery:\n        Anyone can run the lottery if and only if the end date has passed. Tickets for the lottery \n        aren't available for purchase after the lottery has been run.  A pseudorandom number is \n        generated on chain and if there is a match to one of the bought tickets the lottery is \n        complete and the winner may collect their prize via `claim_prize`.  If no match is found \n        then the `run` entry function can be called until a winner is found. \n\n        A lottery cannot be run if it has already been run, if the end date has not passed, or if \n        the minimum number of participants has not been reached.\n\n    Cancellation period:\n        A lottery may be cancelled by anyone if the lottery has not been run and it is at least 7 \n        days past the end date. If the lottery has been cancelled, the creator can receive their NFT \n        back and players can refund their purchased tickets.\n    \n    Burning tickets:\n        At any point, the owner of a ticket can burn their ticket. \n    \n*/\nmodule overmind::nft_lottery {\n    //==============================================================================================\n    // Dependencies - DO NOT MODIFY\n    //==============================================================================================\n    use sui::event;\n    use sui::sui::SUI;\n    use sui::transfer::{Self};\n    use sui::object::{Self, UID, ID};\n    use sui::coin::{Self, Coin};\n    use sui::clock::{Self, Clock};\n    use sui::tx_context::TxContext;\n    use std::option::{Self, Option};\n    use sui::vec_set::{Self, VecSet};\n    use sui::balance::{Self, Balance};\n    \n    \n    //==============================================================================================\n    // Constants - Add your constants here (if any)\n    //==============================================================================================\n\n    //==============================================================================================\n    // Error codes - DO NOT MODIFY\n    //==============================================================================================\n    /// No LotteryCapability\n    const ENoWithdrawalCapability: u64 = 1;\n    /// Invalid range\n    const EInvalidRange: u64 = 2;\n    /// In the past\n    const EStartOrEndTimeInThePast: u64 = 3;\n    /// Lottery has already run\n    const ELotteryHasAlreadyRun: u64 = 4;\n    /// Insufficient funds\n    const EInsufficientFunds: u64 = 5;\n    /// Ticket Already Gone\n    const ETicketAlreadyGone: u64 = 6;\n    /// No prize available\n    const ENoPrizeAvailable: u64 = 7;\n    /// Not winning number\n    const ENotWinningNumber: u64 = 8;\n    /// Ticket Not Available\n    const ETicketNotAvailable: u64 = 9;\n    /// Not withing conditions to abort\n    const ENotCancelled: u64 = 10;\n    /// Invalid number of participants\n    const EInvalidNumberOfParticipants: u64 = 11;\n    /// Ticket not found\n    const ETicketNotFound: u64 = 12;\n    /// Lottery cancelled\n    const ELotteryCancelled: u64 = 13;\n    /// Lottery has no winning number\n    const ELotteryHasNoWinningNumber: u64 = 14;\n    /// Invalid lottery\n    const EInvalidLottery: u64 = 15;\n\n    //==============================================================================================\n    // Module Structs - DO NOT MODIFY\n    //==============================================================================================\n\n    /*\n        The `Lottery` represents a lottery to be run.  A `Lottery` is a Sui shared object which can be created\n        by anyone and the prize is an NFT which is moved to the Lottery shared object.  \n        The creator would receive a `LotteryWithdrawal` object that would give them the capability to\n        make a withdrawal from the Lottery when it has completed.\n        @param id - The object id of the Lottery object.\n        @param nft - The NFT as a prize for the lottery, this will `none` when the prize has been won.\n        @param participants - The minimum required number of participants for the Lottery. The \n        minimum is 1.\n        @param price - The price per ticket of the lottery\n        @param balance - The balance available from the sale of tickets\n        @param range - The upper limit for the lottery numbers. The minimum range is 1000.\n        @param winning_number - The winning number for the lottery. This will be `none` until the lottery has been run.\n        @param start_time - The time in ms since Epoch for when the lottery would accept purchase of tickets\n        @param end_time - The time in ms since Epoch when the lottery will end\n        @param tickets - A set of ticket numbers that have been bought\n        @param cancelled - If the lottery has been cancelled\n    */\n    struct Lottery<T: key + store> has key {\n        id: UID,\n        nft: Option<T>,\n        participants: u64, \n        price: u64,\n        balance: Balance<SUI>,\n        range: u64,\n        winning_number: Option<u64>,\n        start_time: u64,\n        end_time: u64,\n        tickets: VecSet<u64>,\n        cancelled: bool,\n    }\n\n    /*\n        The withdrawal capability struct represents the capability to withdrawal funds from a Lottery. This is \n        created and transferred to the creator of the lottery.\n        @param id - The object id of the withdrawal capability object.\n        @param lottery - The id of the Lottery object.\n    */\n    struct WithdrawalCapability has key {\n        id: UID,\n        lottery: ID, \n    }\n\n    /*\n        The lottery ticket bought by a player\n        @param id - The object id of the withdrawal capability object.\n        @param lottery - The id of the Lottery object.\n        @param ticket_number - The ticket number bought\n    */\n    struct LotteryTicket has key {\n        id: UID,\n        lottery: ID,\n        ticket_number: u64,\n    }\n\n    //==============================================================================================\n    // Event structs - DO NOT MODIFY\n    //==============================================================================================\n\n    /*\n        Event emitted when a Lottery is created.\n        @param lottery - The id of the Lottery object.\n    */\n    struct LotteryCreated has copy, drop {\n        lottery: ID,\n    }\n\n    /*\n        Event emitted when a withdrawal is made from the Lottery\n        @param lottery_id - The id of the Lottery object.\n        @param amount - The amount withdrawn in MIST\n        @param recipient - The recipient of the withdrawal\n    */\n    struct LotteryWithdrawal has copy, drop {\n        lottery: ID,\n        amount: u64,\n        recipient: address,\n    }\n\n    /*\n        Event emitted a ticket is bought for the lottery\n        @param ticket_number - The ticket number bought\n        @param lottery_id - The id of the Lottery object.\n    */\n    struct LotteryTicketBought has copy, drop {\n        ticket_number: u64,\n        lottery: ID,\n    }\n\n    /*\n        Event emitted when there is a winner for the lottery\n        @param winning_number - The winning number\n        @param lottery_id - The id of the Lottery object.\n    */\n    struct LotteryWinner has copy, drop {\n        winning_number: u64,\n        lottery: ID,\n    }\n\n    //==============================================================================================\n    // Functions\n    //==============================================================================================\n\n    /*\n        Create a Lottery for the given NFT and recipient. Abort if the number of participants is \n        less than the minimum participant number, the range is less than the minimum range, the \n        start time is in the past, or the end time is before the start time. \n        @param nft - NFT prize for the lottery created\n        @param participants - Minimum number of participants\n        @param price - Price per ticket in lottery\n        @param range - Upper limit for lottery numbers\n        @param clock - Clock object\n        @param start_time - Start time for lottery\n        @param end_time - End time for lottery\n        @param recipient - Address of recipient of WithdrawalCapability object minted\n        @param ctx - Transaction context.\n */\n    public fun create<T: key + store>(\n        nft: T, \n        participants: u64, \n        price: u64, \n        range: u64, \n        clock: &Clock, \n        start_time: u64, \n        end_time: u64, \n        recipient: address,\n        ctx: &mut TxContext\n    ) {\n        assert!(participants >= 1,EInvalidNumberOfParticipants);\n        assert!(range > 100,EInvalidRange);\n        assert!(start_time < end_time,EStartOrEndTimeInThePast);\n        assert!(start_time >= clock::timestamp_ms(clock),EStartOrEndTimeInThePast);\n\n        let lottery = Lottery {\n            id: object::new(ctx),\n            nft: option::some(nft),\n            participants,\n            price,\n            balance: balance::zero<SUI>(),\n            range,\n            winning_number: option::none(),\n            start_time,\n            end_time,\n            tickets: vec_set::empty(), \n            cancelled: false\n        };\n\n        event::emit(LotteryCreated{\n            lottery: object::id(&lottery)\n        });  \n\n        transfer::transfer( WithdrawalCapability {\n            id: object::new(ctx),\n            lottery: object::id(&lottery),\n        }, recipient);\n        \n        transfer::share_object(lottery);\n\n\n        \n    }\n\n    /*\n        Withdraw the current balance from the lottery to the recipient. Abort if the lottery_cap \n        does not match the lottery, the lottery has been cancelled, or the lottery has not been run.\n        @param lottery_cap - WithdrawalCapability object\n        @param lottery - Lottery object\n        @param recipient - Address of recipient for the withdrawal\n        @param ctx - Transaction context.\n */\n    public fun withdraw<T: key + store>(\n        lottery_cap: &WithdrawalCapability, \n        lottery: &mut Lottery<T>, \n        recipient: address, \n        ctx: &mut TxContext\n    ) {\n        let WithdrawalCapability {id:_ , lottery:lottery_id} = lottery_cap;\n\n        assert!(object::uid_as_inner(&lottery.id) == lottery_id ,ENoWithdrawalCapability);  \n        assert!(!lottery.cancelled,ELotteryCancelled);\n        assert!(option::is_some(&lottery.winning_number),ELotteryHasNoWinningNumber);\n\n        let bal = coin::take(&mut lottery.balance,10,ctx);\n\n        event::emit(LotteryWithdrawal{\n            lottery:  object::uid_to_inner(&lottery.id),\n            amount: coin::value(&bal),\n            recipient,\n        });\n\n        transfer::public_transfer(bal,recipient);}\n\n    /*\n        Buy a lottery ticket for the recipient. Anyone can buy a ticket number of their choosing. \n        Abort if the lottery has been cancelled, the lottery has already been run, the payment is \n        less than the price per ticket, the ticket number is greater than the range, or the ticket \n        number has already been bought. \n        @param ticket_number - The ticket number we wish to buy\n        @param lottery - Lottery object\n        @param payment - Payment in SUI for the ticket\n        @param recipient - Address of recipient for the withdrawal\n        @param ctx - Transaction context.\n */\n    public fun buy<T: key + store>(\n        ticket_number: u64, \n        lottery: &mut Lottery<T>, \n        payment: &mut Coin<SUI>, \n        recipient: address, \n        ctx: &mut TxContext\n    ) {\n        assert!(!lottery.cancelled,ELotteryCancelled);\n        assert!(!option::is_some(&lottery.winning_number),EStartOrEndTimeInThePast);\n        assert!(coin::value(payment) >= lottery.price ,EInsufficientFunds);\n        assert!(ticket_number <= lottery.range,EInvalidRange);\n        assert!(!vec_set::contains(&lottery.tickets,&ticket_number),ETicketAlreadyGone);\n\n        let ticket_bal = coin::balance_mut<SUI>(payment);\n        let bal = balance::withdraw_all(ticket_bal);\n        balance::join(&mut lottery.balance , bal);\n\n        let ticket = LotteryTicket {\n        id: object::new(ctx) ,\n        lottery: object::uid_to_inner(&lottery.id),\n        ticket_number,\n        };\n\n        vec_set::insert(&mut lottery.tickets, ticket.ticket_number);\n        transfer::transfer(ticket,recipient);\n\n        event::emit( LotteryTicketBought {\n            ticket_number,\n            lottery: object::uid_to_inner(&lottery.id),\n        });\n    }\n\n    /*\n        Generates the random number and ends the lottery with it. (DON'T MODIFY)\n        @param lottery - Lottery object\n        @param clock - Clock object\n        @param ctx - Transaction context.\n */\n    public fun run<T: key + store>(\n        lottery: &mut Lottery<T>, \n        clock: &Clock, \n        ctx: &mut TxContext\n    ) {\n        let winning_number = overmind::random::generate_number(lottery.range, ctx);\n        run_internal(lottery, clock, winning_number)\n    }\n\n    /*\n        Updates the lottery if a winner is found. Abort if the lottery has already been run, the lottery \n        has been cancelled, the lottery has not yet ended, or the lottery has not yet reached the \n        minimum number of participants.\n        @param lottery - Lottery object\n        @param clock - Clock object\n */\n    fun run_internal<T: key + store>(\n        lottery: &mut Lottery<T>, \n        clock: &Clock,\n        winning_number: u64\n    ) {\n        // assert!(option::is_some(&lottery.winning_number),ENotWinningNumber);\n        assert!(!lottery.cancelled,ELotteryCancelled);\n        assert!(lottery.end_time < clock::timestamp_ms(clock), EStartOrEndTimeInThePast);\n        // assert!(vec_set::size(&lottery.tickets) >= 1, EInvalidNumberOfParticipants);\n\n        event::emit( LotteryWinner {\n            lottery: object::uid_to_inner(&lottery.id),\n            winning_number,\n        });\n\n        lottery.winning_number = option::some(winning_number);\n\n\n\n\n    }\n    \n    /*\n        Claim prize for the winning ticket. Abort if the lottery has not been run, the lottery \n        ticket does not match the lottery, the lottery has no NFT prize, or the lottery ticket is\n        not the winning number.\n        @param lottery - Lottery object\n        @param ticket - Winning lottery ticket\n        @param recipient - Recipient to receive the prize\n */\n    public fun claim_prize<T: key + store>(\n        lottery: &mut Lottery<T>, \n        ticket: &LotteryTicket, \n        recipient: address\n    ) {\n        assert!(option::is_some(&lottery.nft),ENoPrizeAvailable);\n        assert!(option::is_some(&lottery.winning_number), ELotteryHasNoWinningNumber);\n        assert!(ticket.lottery == object::uid_to_inner(&lottery.id),EInvalidLottery);\n        assert!(ticket.ticket_number == option::extract(&mut lottery.winning_number) ,ENotWinningNumber);\n\n        transfer::public_transfer(option::extract(&mut lottery.nft),recipient);\n\n\n        \n    } \n\n    /*\n        Cancels the lottery if it has not been cancelled already. Send the ticket cost back to the \n        recipient. Abort if the lottery cannot be cancelled, or if the ticket has already been \n        refunded. \n        @param lottery - Lottery object\n        @param clock - Clock object\n        @param ticket - Lottery ticket object\n        @param recipient - Recipient to receive refund\n        @param ctx - Transaction context.\n */\n    public fun refund<T: key + store>(\n        lottery: &mut Lottery<T>, \n        clock: &Clock, \n        ticket: &LotteryTicket, \n        recipient: address, \n        ctx: &mut TxContext\n    ) {\n\n        if (!lottery.cancelled){\n            lottery.cancelled = true;\n        };\n\n        \n        let seven_days_in_milliseconds:u64 = 7*24*60*60*1000;\n        assert!(lottery.end_time + seven_days_in_milliseconds < clock::timestamp_ms(clock),ENotCancelled);\n        assert!(option::is_none(&lottery.winning_number),ELotteryHasAlreadyRun);\n        \n\n        assert!(vec_set::contains(&lottery.tickets,&ticket.ticket_number),ETicketNotAvailable);\n        \n\n        let bal = balance::split(&mut lottery.balance,lottery.price);\n        let refund_coin = coin::from_balance(bal,ctx);\n        transfer::public_transfer(refund_coin,recipient);\n\n        vec_set::remove(&mut lottery.tickets , &ticket.ticket_number)\n\n        \n        \n        \n    }\n\n    /*\n        Cancels the lottery if it has not been cancelled already. Send the NFT to the recipient. \n        Abort if the lottery cannot be canceled, or if there is no NFT prize.\n        @param lottery - Lottery object\n        @param clock - Clock object\n        @param recipient - Recipient to receive refund\n        @param withdrawal_cap - WithdrawalCapability object\n */\n    public fun return_nft<T: key + store>(\n        lottery: &mut Lottery<T>, \n        clock: &Clock, \n        recipient: address, \n        withdrawal_cap: WithdrawalCapability\n    ) {\n            let WithdrawalCapability {id:id,lottery:_} = withdrawal_cap;\n        if (!lottery.cancelled){\n            lottery.cancelled = true;\n        };\n        let seven_days_in_milliseconds:u64 = 7*24*60*60*1000;\n        assert!(lottery.end_time + seven_days_in_milliseconds < clock::timestamp_ms(clock),ENotCancelled);\n        assert!(option::is_none(&lottery.winning_number),ELotteryHasAlreadyRun);\n\n        assert!(option::is_some(&lottery.nft),ENoPrizeAvailable);\n\n        transfer::public_transfer(option::extract(&mut lottery.nft),recipient);\n        object::delete(id)\n\n\n    }\n\n    /*\n        Destroy the given ticket and remove it from the lottery. Abort if the ticket is not found in \n        the lottery.\n        @param lottery - Lottery the ticket was bought for\n        @param ticket - Ticket to be burnt\n */\n    public fun burn_ticket<T: key + store>(\n        lottery: &mut Lottery<T>,\n        ticket: LotteryTicket\n    ) {\n        assert!(vec_set::contains(&lottery.tickets, &ticket.ticket_number),ETicketNotFound);\n        let LotteryTicket { id:id , lottery:_, ticket_number:_ } = ticket;\n        object::delete(id)\n\n        \n    }\n\n    //==============================================================================================\n    // Helper functions - Add your helper functions here (if any)\n    //==============================================================================================\n\n    //==============================================================================================\n    // Validation functions - Add your validation functions here (if any)\n    //==============================================================================================\n\n    // inline fun abort_if_cancelled (lottery:&Lottery){\n    //     assert!(!lottery.canceled,ELotteryCancelled);\n    // };\n    // inline fun abort_if_not_cancelled (lottery:&Lottery){\n    //     assert!(lottery.canceled,ENotCancelled);\n    // }\n    \n    //==============================================================================================\n    // Tests\n    //==============================================================================================\n    \n    "} ]}

