{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `digital assets` in the sui move language?"}, {"role": "assistant", "content": "\n# Move - Language for Digital Assets\n\n\nSmart-contract programming languages have historically focused on defining and managing digital\nassets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with\ndigital currency tokens, establishing a blueprint for creating and managing digital currencies on\nthe blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant\nevolution, popularising the concept of non-fungible tokens (NFTs), which represent unique,\nindivisible assets. These standards laid the groundwork for the complex digital assets we see today.\n\n\n\nHowever, Ethereum's programming model lacked a native representation of assets. In other words,\nexternally, a Smart Contract behaved like an asset, but the language itself did not have a way to\ninherently represent assets. From the start, Move aimed to provide a first-class abstraction for\nassets, opening up new avenues for thinking about and programming assets.\n\n\nIt is important to highlight which properties are essential for an asset:\n\n* \nOwnership: Every asset is associated with an owner(s), mirroring the straightforward concept\nof ownership in the physical world—just as you own a car, you can own a digital asset. Move\nenforces ownership in such a way that once an asset is moved, the previous owner completely\nloses any control over it. This mechanism ensures a clear and secure change of ownership.\n\n\n\n* \nNon-copyable: In the real world, unique items cannot be duplicated effortlessly. Move applies\nthis principle to digital assets, ensuring they cannot be arbitrarily copied within the program.\nThis property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring\nthe intrinsic value of physical assets.\n\n\n\n* \nNon-discardable: Just as you cannot accidentally lose a house or a car without a trace, Move\nensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly\ntransferred or destroyed. This property guarantees the deliberate handling of digital assets,\npreventing accidental loss and ensuring accountability in asset management.\n\n\n\nMove managed to encapsulate these properties in its design, becoming an ideal language for digital\nassets.\n\n## Summary\n\n\n* Move was designed to provide a first-class abstraction for digital assets, enabling developers to\ncreate and manage assets natively.\n\n* Essential properties of digital assets include ownership, non-copyability, and non-discardability,\nwhich Move enforces in its design.\n\n* Move's asset model mirrors real-world asset management, ensuring secure and accountable asset\nownership and transfer.\n\n## Further reading\n\n\n* [Move: A Language With Programmable Resources (pdf)](https://developers.diem.com/papers/diem-move-a-language-with-programmable-resources/2019-06-18.pdf)\nby Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott,\nShaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou*\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is `Move Evolution` in the sui move language?"}, {"role": "assistant", "content": "\n# Evolution of Move\n\n\nWhile Move was created to manage digital assets, its initial storage model was bulky and not\nwell-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had\nto create a new \"empty\" resource, and then Alice could transfer asset X to Bob. This process was not\nintuitive and presented implementation challenges, partly due to the restrictive design of\nDiem. Another drawback of the original design was the lack of built-in\nsupport for a \"transfer\" operation, requiring every module to implement its own storage transfer\nlogic. Additionally, managing heterogeneous collections of assets in a single account was\nparticularly challenging.\n\nSui addressed these challenges by redesigning the storage and ownership model of objects to more\nclosely resemble real-world object interactions. With a native concept of ownership and transfer,\nAlice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different\nassets without any preparatory steps. These improvements laid the foundation for the Object Model in\nSui.\n\n## Summary\n\n\n* Move's initial storage model was not well-suited for managing digital assets, requiring complex\nand restrictive transfer operations.\n\n* Sui introduced the Object Model, which provides a native concept of ownership, simplifying asset\nmanagement and enabling heterogeneous collections.\n\n## Further reading\n\n\n* [Why We Created Sui Move](https://blog.sui.io/why-we-created-sui-move/) by Sam Blackshear\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is `Object` in the sui move language?"}, {"role": "assistant", "content": "\n# What is an Object?\n\n\nThe Object Model in Sui can be viewed as a high-level abstraction representing digital assets as\nobjects. These objects have their own type and associated behaviors, a unique identifier, and\nsupport native storage operations like transfer and share. Designed to be intuitive and easy to\nuse, the Object Model enables a wide range of use cases to be implemented with ease.\n\nObjects in Sui have the following properties:\n\n* \nType: Every object has a type, defining the structure and behavior of the object. Objects of\ndifferent types cannot be mixed or used interchangeably, ensuring objects are used correctly\naccording to their type system.\n\n\n\n* \nUnique ID: Each object has a unique identifier, distinguishing it from other objects. This ID\nis generated upon the object's creation and is immutable. It's used to track and identify objects\nwithin the system.\n\n\n\n\n* \nOwner: Every object is associated with an owner, who has control over the object. Ownership on\nSui can be exclusive to an account, shared across the network, or frozen, allowing read-only\naccess without modification or transfer capabilities. We will discuss ownership in more detail in\nthe following sections.\n\n\n\n* \nData: Objects encapsulate their data, simplifying management and manipulation. The data\nstructure and operations are defined by the object's type.\n\n\n\n* \nVersion: The transition from accounts to objects is facilitated by object versioning.\nTraditionally, blockchains use a nonce to prevent replay attacks. In Sui, the object's version\nacts as a nonce, preventing replay attacks for each object.\n\n\n\n* \nDigest: Every object has a digest, which is a hash of the object's data. The digest is used to\ncryptographically verify the integrity of the object's data and ensures that it has not been\ntampered with. The digest is calculated when the object is created and is updated whenever the\nobject's data changes.\n\n\n\n## Summary\n\n\n* Objects in Sui are high-level abstractions representing digital assets.\n\n* Objects have a type, unique ID, owner, data, version, and digest.\n\n* The Object Model simplifies asset management and enables a wide range of use cases.\n\n## Further reading\n\n\n* [Object Model](https://docs.sui.io/concepts/object-model) in Sui Documentation.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is `Ownership` in the sui move language?"}, {"role": "assistant", "content": "\n# Ownership\n\n\nSui introduces four distinct ownership types for objects: single owner, shared state, immutable\nshared state, and object-owner. Each model offers unique characteristics and suits different use\ncases, enhancing flexibility and control in object management.\n\n## Account Owner (or Single Owner)\n\n\nThe account owner, also known as the single owner model, is the foundational ownership type in\nSui. Here, an object is owned by a single account, granting that account exclusive control over the\nobject within the behaviors associated with its type. This model embodies the concept of true\nownership, where the account possesses complete authority over the object, making it inaccessible\nto others for modification or transfer. This level of ownership clarity is a significant advantage\nover other blockchain systems, where ownership definitions can be more ambiguous, and smart\ncontracts may have the ability to alter or transfer assets without the owner's consent.\n\n\n## Shared State\n\n\nSingle owner model has its limitations: for example, it is very tricky to implement a marketplace\nfor digital assets without a shared state. For a generic marketplace scenario, imagine that Alice\nowns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come\nand buy the asset directly from the marketplace. The reason why this is tricky is that it is\nimpossible to write a smart contract that would \"lock\" the asset in Alice's account and take it out\nwhen Bob buys it. First, it will be a violation of the single owner model, and second, it requires a\nshared access to the asset.\n\nTo facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this\nmodel, an object can be shared with the network. Shared objects can be read and modified by any\naccount on the network, and the rules of interaction are defined by the implementation of the\nobject. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other\nscenarios where multiple accounts need access to the same state.\n\n## Immutable (Frozen) State\n\n\nSui also offers the frozen object model, where an object becomes permanently read-only. These\nimmutable objects, while readable, cannot be modified or moved, providing a stable and constant\nstate accessible to all network participants. Frozen objects are ideal for public data, reference\nmaterials, and other use cases where the state permanence is desirable.\n\n## Object Owner\n\n\nThe last ownership model in Sui is the object owner. In this model, an object is owned by another\nobject. This feature allows creating complex relationships between objects, store large\nheterogenious collections, and implementing extensible and modular systems. Practically speaking,\nsince the transactions are initiated by accounts, the transaction still accesses the parent object,\nbut it can then access the child objects through the parent object.\n\nA use case we love to mention is a game character. Alice can own the Hero object from a game, and\nthe Hero can own items: also represented as objects, like a \"Map\", or a \"Compass\". Alice may take\nthe \"Map\" from the \"Hero\" object, and then send it to Bob, or sell it on a marketplace. With object\nowner, it becomes very natural to imagine how the assets can be structured and managed in relation\nto each other.\n\n## Summary\n\n\n* **Single Owner:**\n Objects are owned by a single account, granting exclusive control over the\nobject.\n\n* **Shared State:**\n Objects can be shared with the network, allowing multiple accounts to read and\nmodify the object.\n\n* **Immutable State:**\n Objects become permanently read-only, providing a stable and constant state.\n\n* **Object Owner:**\n Objects can own other objects, enabling complex relationships and modular\nsystems.\n\n## Next Steps\n\n\nIn the next section we will talk about transaction execution paths in Sui, and how the ownership\nmodels affect the transaction execution.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are  `Fast Path and Consensus Path` in the sui move language?"}, {"role": "assistant", "content": "\n# Fast Path & Consensus\n\n\nThe Object Model allows for variable transaction execution paths, depending on the object's\nownership type. The transaction execution path determines how the transaction is processed and\nvalidated by the network. In this section, we'll explore the different transaction execution paths\nin Sui and how they interact with the consensus mechanism.\n\n## Concurrency Challenge\n\n\nAt its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may\ntry to modify or access the same data simultaneously in a decentralized environment. This requires a\nsystem for sequencing and validating transactions to support the network's consistency. Sui\naddresses this challenge through a consensus mechanism, ensuring all nodes agree on the\ntransactions' sequence and state.\n\nConsider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same\nasset. The network must resolve this conflict to prevent double-spending, ensuring that at most one\ntransaction succeeds while the other is rightfully rejected.\n\n## Fast Path\n\n\nHowever, not all transactions require the same level of validation and consensus. For example, if\nAlice wants to transfer an object that she owns to Bob, the network can process this transaction\nwithout sequencing it with respect to all other transactions in the network, as only Alice has the\nauthority to access the object. This is known as the fast path execution, where transactions\naccessing account-owned objects are processed quickly without the need for extensive consensus. No\nconcurrent data access -> simpler challenge -> fast path.\n\nAnother ownership model that allows for fast path execution is the immutable state. Since\nimmutable objects cannot change, transactions involving them can be processed quickly without the\nneed to sequence them.\n\n## Consensus Path\n\n\nTransactions that do access shared state - on Sui it is represented with shared objects - require\nsequencing to ensure that the state is updated and consistented across all nodes. This is known as\nthe execution through consensus, where transactions accessing shared objects are subject to the\nagreement process to maintain network consistency.\n\n\n## Objects owned by Objects\n\n\nLastly, it is important to mention that objects owned by other objects are subject to the same rules\nas the parent object. If the parent object is shared, the child object is also transitively\nshared. If the parent object is immutable, the child object is also immutable.\n\n## Summary\n\n\n* **Fast Path:**\n Transactions involving account-owned objects or immutable shared state are\nprocessed quickly without the need for extensive consensus.\n\n* **Consensus Path:**\n Transactions involving shared objects require sequencing and consensus to\nensure network integrity.\n\n* **Objects owned by Objects:**\n Child objects inherit the ownership model of the parent object.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are  `Key Ability` in the sui move language?"}, {"role": "assistant", "content": "\n# The Key Ability\n\n\nIn the Basic Syntax chapter we already covered two out of four abilities -\nDrop and Copy. They affect the behaviour of the value in a\nscope and are not directly related to storage. It is time to cover the `key`\n ability, which allows\nthe struct to be stored.\n\nHistorically, the `key`\n ability was created to mark the type as a key in the storage. A type with\nthe `key`\n ability could be stored at top-level in the storage, and could be directly owned by an\naccount or address. With the introduction of the Object Model, the `key`\n ability\nnaturally became the defining ability for the object.\n\n\n## Object Definition\n\n\nA struct with the `key`\n ability is considered an object and can be used in the storage functions.\nThe Sui Verifier will require the first field of the struct to be named `id`\n and have the type\n`UID`\n.\n\n```move`public struct Object has key {\n    id: UID, // required\n    name: String,\n}\n\n/// Creates a new Object with a Unique ID\npublic fun new(name: String, ctx: &mut TxContext): Object {\n    Object {\n        id: object::new(ctx), // creates a new UID\n        name,\n    }\n}\n`\n```\n\nA struct with the `key`\n ability is still a struct, and can have any number of fields and associated\nfunctions. There is no special handling or syntax for packing, accessing or unpacking the struct.\n\nHowever, because the first field of an object struct must be of type `UID`\n - a non-copyable and\nnon-droppable type (we will get to it very soon!), the struct transitively cannot have `drop`\n and\n`copy`\n abilities. Thus, the object is non-discardable by design.\n\n\n## Types with the key Ability\n\n\nDue to the `UID`\n requirement for types with `key`\n, none of the native types in Move can have the\n`key`\n ability, nor can any of the Standard Library types.\nThe `key`\n ability is only present in the Sui Framework and\ncustom types.\n\n## Next Steps\n\n\nKey ability defines the object in Move, and objects are intended to be stored. In the next section\nwe present the `sui::transfer`\n module, which provides native storage functions for objects.\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How to use `Storage Functions` in the sui move language?"}, {"role": "assistant", "content": "\n# Storage Functions\n\n\nThe module that defines main storage operations is `sui::transfer`\n. It is implicitly imported in all\npackages that depend on the Sui Framework, so, like other\nimplicitly imported modules (e.g. `std::option`\n or `std::vector`\n), it does not require adding a use\nstatement.\n\n## Overview\n\n\nThe `transfer`\n module provides functions to perform all three storage operations matching\nownership types which we explained before:\n\n\nOn this page we will only talk about so-called restricted storage operations, later we will\ncover public ones, after the `store`\n ability is introduced.\n\n\n1. *Transfer*\n - send an object to an address, put it into *account owned*\n state;\n2. *Share*\n - put an object into a *shared*\n state, so it is available to everyone;\n3. *Freeze*\n - put an object into *immutable*\n state, so it becomes a public constant and can never\nchange.\n\nThe `transfer`\n module is a go-to for most of the storage operations, except a special case with\nDynamic Fields awaits us in the next chapter.\n\n## Ownership and References: A Quick Recap\n\n\nIn the Ownership and Scope and\nReferences chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:\n\n* The *move*\n semantics in Move means that the value is *moved*\n from one scope to another. In other\nwords, if an instance of a type is passed to a function *by value*\n, it is *moved*\n to the function\nscope and can't be accessed in the caller scope anymore.\n\n* To maintain the ownership of the value, you can pass it *by reference*\n. Either by *immutable\nreference*\n `&T`\n or *mutable reference*\n `&mut T`\n. Then the value is *borrowed*\n and can be accessed\nin the caller scope, however the owner stays the same.\n\n```move`/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n`\n```\n\n\n## Transfer\n\n\nThe `transfer::transfer`\n function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the `key`\n ability\nand an address of the recipient. Please, note that the object is\npassed into the function by value, therefore it is moved to the function scope and then moved to\nthe recipient address:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n`\n```\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender.\n\n```move`module book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n`\n```\n\nWhen the module is published, the `init`\n function will get called, and the `AdminCap`\n object which\nwe created there will be transferred to the transaction sender. The `ctx.sender()`\n function\nreturns the sender address for the current transaction.\n\nOnce the `AdminCap`\n has been transferred to the sender, for example, to `0xa11ce`\n, the sender, and\nonly the sender, will be able to access the object. The object is now account owned.\n\n\nAccount owned objects are a subject to true ownership - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model.\n\n\nLet's extend the example with a function that uses `AdminCap`\n to authorize a mint of a new object\nand its transfer to another address:\n\n```move`/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n`\n```\n\nThe `mint_and_transfer`\n function is a public function that \"could\" be called by anyone, but it\nrequires an `AdminCap`\n object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled Capability. Because the `AdminCap`\n object is account\nowned, only `0xa11ce`\n will be able to call the `mint_and_transfer`\n function.\n\nThe `Gift`\ns sent to recipients will also be account owned, each gift being unique and owned\nexclusively by the recipient.\n\nA quick recap:\n\n* `transfer`\n function is used to send an object to an address;\n\n* The object becomes *account owned*\n and can only be accessed by the recipient;\n\n* Functions can be gated by requiring an object to be passed as an argument, creating a\n*capability*\n.\n\n## Freeze\n\n\nThe `transfer::freeze`\n function is public function used to put an object into an immutable state.\nOnce an object is frozen, it can never be changed, and it can be accessed by anyone by immutable\nreference.\n\nThe function signature is as follows, only accepts a type with the\n`key`\n ability. Just like all other storage functions, it takes the object by\nvalue:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n`\n```\n\nLet's expand on the previous example and add a function that allows the admin to create a `Config`\n\nobject and freeze it:\n\n```move`/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n`\n```\n\nConfig is an object that has a `message`\n field, and the `create_and_freeze`\n function creates a new\n`Config`\n and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The `message`\n function is a public function that returns the message from the `Config`\n\nobject. Config is now publicly available by its ID, and the message can be read by anyone.\n\n\nFunction definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object.\n\n\nThe `message`\n function can be called on an immutable `Config`\n object, however, two functions below\nare not callable on a frozen object:\n\n```move`// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nTo summarize:\n\n* `freeze_object`\n function is used to put an object into an *immutable*\n state;\n\n* Once an object is *frozen*\n, it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;\n\n## Owned -> Frozen\n\n\nSince the `transfer::freeze`\n signature accepts any type with the `key`\n ability, it can take an\nobject that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the `freeze_object`\n function can be used to freeze an object that was\ntransferred to the sender. For security concerns, we would not want to freeze the `AdminCap`\n\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n`Gift`\n object that was minted and transferred to the recipient:\n\n\nSingle Owner -> Immutable conversion is possible!\n\n\n```move`/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n`\n```\n\n## Share\n\n\nThe `transfer::share`\n function is a public function used to put an object into a shared state.\nOnce an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n`key`\n ability:\n\n```move`// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n`\n```\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\n## Special Case: Shared Object Deletion\n\n\nWhile the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:\n\n```move`/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n`\n```\n\nThe `create_and_share`\n function creates a new `Config`\n object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n```move`/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n`\n```\n\nThe `delete_config`\n function takes the `Config`\n object by value and deletes it, and Sui Verifier\nwould allow this call. However, if the function returned the `Config`\n object back or attempted to\n`freeze`\n or `transfer`\n it, the Sui Verifier would reject the transaction.\n\n```move`// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n`\n```\n\nTo summarize:\n\n* `share_object`\n function is used to put an object into a *shared*\n state;\n\n* Once an object is *shared*\n, it can be accessed by anyone by a mutable reference;\n\n* Shared objects can be deleted, but they can't be transferred or frozen.\n\n## Next Steps\n\n\nNow that you know main features of the `transfer`\n module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\nStore Ability which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\nUID and ID types which are the most important types in the Sui storage model.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How to use `store ability` in the sui move language?"}, {"role": "assistant", "content": "\n# Ability: Store\n\n\nNow that you have an understanding of top-level storage functions which are enabled by the\n`key`\n ability, we can talk about the last ability in the list - `store`\n.\n\n## Definition\n\n\nThe `store`\n is a special ability that allows a type to be stored in objects. This ability is\nrequired for the type to be used as a field in a struct that has the `key`\n ability. Another way to\nput it is that the `store`\n ability allows the value to be wrapped in an object.\n\n\nThe `store`\n ability also relaxes restrictions on transfer operations. We talk about it more in the\nRestricted and Public Transfer section.\n\n\n## Example\n\n\nIn previous sections we already used types with the `store`\n ability: all objects must have a `UID`\n\nfield, which we used in examples; we also used the `String`\n type as a part of the `Config`\n struct.\nThe `String`\n type also has the `store`\n ability.\n\n```move`/// This type has the `store` ability.\npublic struct Storable has store {}\n\n/// Config contains a `Storable` field which must have the `store` ability.\npublic struct Config has key, store {\n    id: UID,\n    stores: Storable,\n}\n\n/// MegaConfig contains a `Config` field which has the `store` ability.\npublic struct MegaConfig has key {\n    id: UID,\n    config: Config, // there it is!\n}\n`\n```\n\n## Types with the store Ability\n\n\nAll native types (except for references) in Move have the `store`\n ability. This includes:\n\n* [bool](./../move-basics/primitive-types.html#booleans)\n\n* [unsigned integers](./../move-basics/primitive-types.html#integers)\n\n* [vector](./../move-basics/vector.html)\n\n* [address](./../move-basics/address.html)\n\nAll of the types defined in the standard library have the `store`\n ability as well. This includes:\n\n* [Option](./../move-basics/option.html)\n\n* [String](./../move-basics/string.html)\n\n* [TypeName](./../move-basics/type-reflection.html#typename)\n\n## Further reading\n\n\n* [Type Abilities](/reference/type-abilities.html) in the Move Reference.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `UID and ID` in the sui move language?"}, {"role": "assistant", "content": "\n# UID and ID\n\n\nThe `UID`\n type is defined in the `sui::object`\n module and is a wrapper around an `ID`\n which, in\nturn, wraps the `address`\n type. The UIDs on Sui are guaranteed to be unique, and can't be reused\nafter the object was deleted.\n\n```move`// File: sui-framework/sources/object.move\n/// UID is a unique identifier of an object\npublic struct UID has store {\n    id: ID\n}\n\n/// ID is a wrapper around an address\npublic struct ID has store, drop {\n    bytes: address\n}\n`\n```\n\n\n## Fresh UID generation:\n\n\n* UID is derived from the `tx_hash`\n and an `index`\n which is incremented for each new UID.\n\n* The `derive_id`\n function is implemented in the `sui::tx_context`\n module, and that is why TxContext\nis required for UID generation.\n\n* Sui Verifier will not allow using a UID that wasn't created in the same function. That prevents\nUIDs from being pre-generated and reused after the object was unpacked.\n\nNew UID is created with the `object::new(ctx)`\n function. It takes a mutable reference to TxContext,\nand returns a new UID.\n\n```move`let ctx = &mut tx_context::dummy();\nlet uid = object::new(ctx);\n`\n```\n\nOn Sui, `UID`\n acts as a representation of an object, and allows defining behaviors and features of\nan object. One of the key-features - Dynamic Fields - is possible because of the `UID`\n type\nbeing explicit. Additionally, it allows the Transfer To Object (TTO) which we will explain later\nin this chapter.\n\n## UID lifecycle\n\n\nThe `UID`\n type is created with the `object::new(ctx)`\n function, and it is destroyed with the\n`object::delete(uid)`\n function. The `object::delete`\n consumes the UID by value, and it is\nimpossible to delete it unless the value was unpacked from an Object.\n\n```move`let ctx = &mut tx_context::dummy();\n\nlet char = Character {\n    id: object::new(ctx)\n};\n\nlet Character { id } = char;\nid.delete();\n`\n```\n\n## Keeping the UID\n\n\nThe `UID`\n does not need to be deleted immediately after the object struct is unpacked. Sometimes it\nmay carry Dynamic Fields or objects transferred to it via\nTransfer To Object. In such cases, the UID may be kept and stored in a\nseparate object.\n\n## Proof of Deletion\n\n\nThe ability to return the UID of an object may be utilized in pattern called proof of deletion. It\nis a rarely used technique, but it may be useful in some cases, for example, the creator or an\napplication may incentivize the deletion of an object by exchanging the deleted IDs for some reward.\n\nIn framework development this method could be used ignore / bypass certain restrictions on \"taking\"\nthe object. If there's a container that enforces certain logic on transfers, like Kiosk does, there\ncould be a special scenario of skipping the checks by providing a proof of deletion.\n\nThis is one of the open topics for exploration and research, and it may be used in various ways.\n\n## ID\n\n\nWhen talking about `UID`\ns we should also mention the `ID`\n type. It is a wrapper around the `address`\n\ntype, and is used to represent an address-pointer. Usually, `ID`\n is used to point at an object,\nhowever, there's no restriction, and no guarantee that the `ID`\n points to an existing object.\n\n\nID can be received as a transaction argument in a Transaction Block. Alternatively, ID can be\ncreated from an `address`\n value using `to_id()`\n function.\n\n\n\n## fresh_object_address\n\n\nTxContext provides the `fresh_object_address`\n function which can be utilized to create unique\naddresses and `ID`\ns - it may be useful in some application that assign unique identifiers to user\nactions - for example, an order_id in a marketplace.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `URestricted and Public Transfer` in the sui move language?"}, {"role": "assistant", "content": "\n# Restricted and Public Transfer\n\n\nStorage Operations that we described in the previous sections are\nrestricted by default - they can only be called in the module defining the object. In other terms,\nthe type must be internal to the module to be used in storage operations. This restriction is\nimplemented in the Sui Verifier and is enforced at the bytecode level.\n\nHowever, to allow objects to be transferred and stored in other modules, these restrictions can be\nrelaxed. The `sui::transfer`\n module offers a set of public_* functions that allow calling\nstorage operations in other modules. The functions are prefixed with `public_`\n and are available to\nall modules and transactions.\n\n## Public Storage Operations\n\n\nThe `sui::transfer`\n module provides the following public functions. They are almost identical to the\nones we already covered, but can be called from any module.\n\n```move`// File: sui-framework/sources/transfer.move\n/// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(object: T, to: address) {}\n\n/// Public version of the `share_object` function.\npublic fun public_share_object<T: key + store>(object: T) {}\n\n/// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(object: T) {}\n`\n```\n\nTo illustrate the usage of these functions, consider the following example: module A defines an\nObjectK with `key`\n and ObjectKS with `key + store`\n abilities, and module B tries to implement a\n`transfer`\n function for these objects.\n\n\nIn this example we use `transfer::transfer`\n, but the behaviour is identical for `share_object`\n and\n`freeze_object`\n functions.\n\n\n```move`/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`\n/// abilities respectively\nmodule book::transfer_a {\n    public struct ObjectX has key { id: UID }\n    public struct ObjectKS has key, store { id: UID }\n}\n\n/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts\n/// to implement different `transfer` functions for them\nmodule book::transfer_b {\n    // types are not internal to this module\n    use book::transfer_a::{ObjectK, ObjectKS};\n\n    // Fails! ObjectX is not `store`, and ObjectX is not internal to this module\n    public fun transfer_k(k: ObjectK, to: address) {\n        sui::transfer::transfer(k, to);\n    }\n\n    // Fails! ObjectKS has `store` but the function is not public\n    public fun transfer_ks(ks: ObjectKS, to: address) {\n        sui::transfer::transfer(ks, to);\n    }\n\n    // Fails! ObjectK is not `store`, `public_transfer` requires `store`\n    public fun public_transfer_k(k: ObjectK) {\n        sui::transfer::public_transfer(k);\n    }\n\n    // Works! ObjectKS has `store` and the function is public\n    public fun public_transfer_ks(y: ObjectKS, to: address) {\n        sui::transfer::public_transfer(y, to);\n    }\n}\n`\n```\n\nTo expand on the example above:\n\n* \n`transfer_x`\n fails because ObjectK is not internal to module `transfer_b`\n\n\n* \n`transfer_y`\n fails because ObjectKS is not internal to module `transfer_b`\n\n\n* \n`public_transfer_x`\n fails because ObjectK does not have the `store`\n ability\n\n* \n`public_transfer_y`\n works because ObjectKS has the `store`\n ability and the transfer is public\n\n## Implications of store\n\n\nThe decision on whether to add the `store`\n ability to a type should be made carefully. On one hand,\nit is de-facto a requirement for the type to be usable by other applications. On the other hand,\nit allows wrapping and changing the intended storage model. For example, a character may be\nintended to be owned by accounts, but with the `store`\n ability it can be frozen (cannot be shared -\nthis transition is restricted).\n\n"}]}
