{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " How to install `Sui Move` in the sui move language?"}, {"role": "assistant", "content": "\n# Move 2024 Migration Guide\n\n\nMove 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is\nintended to help you understand the differences between the 2024 edition and the previous version of\nthe Move language.\n\n\nThis guide provides a high-level overview of the changes in the new edition. For a more detailed\nand exhaustive list of changes, refer to the\nSui Documentation.\n\n\n## Using the New Edition\n\n\nTo use the new edition, you need to specify the edition in the `move`\n file. The edition is specified\nin the `move`\n file using the `edition`\n keyword. Currently, the only available edition is\n`2024.beta`\n.\n\n```move`edition = \"2024.beta\";\n`\n```\n\n## Migration Tool\n\n\nThe Move CLI has a migration tool that updates the code to the new edition. To use the migration\ntool, run the following command:\n\n```move`$ sui move migrate\n`\n```\n\nThe migration tool will update the code to use the `let mut`\n syntax, the new `public`\n modifier for\nstrucs, and the `public(package)`\n function visibility instead of `friend`\n declarations.\n\n## Mutable bindings with let mut\n\n\nMove 2024 introduces `let mut`\n syntax to declare mutable variables. The `let mut`\n syntax is used to\ndeclare a mutable variable that can be changed after it is declared.\n\n\n`let mut`\n declaration is now required for mutable variables. Compiler will emit an error if you\ntry to reassign a variable without the `mut`\n keyword.\n\n\n```move`// Move 2020\nlet x: u64 = 10;\nx = 20;\n\n// Move 2024\nlet mut x: u64 = 10;\nx = 20;\n`\n```\n\nAdditionally, the `mut`\n keyword is used in tuple destructuring and function arguments to declare\nmutable variables.\n\n```move`// takes by value and mutates\nfun takes_by_value_and_mutates(mut v: Value): Value {\n    v.field = 10;\n    v\n}\n\n// `mut` should be placed before the variable name\nfun destruct() {\n    let (x, y) = point::get_point();\n    let (mut x, y) = point::get_point();\n    let (mut x, mut y) = point::get_point();\n}\n\n// in struct unpack\nfun unpack() {\n    let Point { x, mut y } = point::get_point();\n    let Point { mut x, mut y } = point::get_point();\n}\n`\n```\n\n## Friends are Deprecated\n\n\nIn Move 2024, the `friend`\n keyword is deprecated. Instead, you can use the `public(package)`\n\nvisibility modifier to make functions visible to other modules in the same package.\n\n```move`// Move 2020\nfriend book::friend_module;\npublic(friend) fun protected_function() {}\n\n// Move 2024\npublic(package) fun protected_function_2024() {}\n`\n```\n\n## Struct Visibility\n\n\nIn Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier\nis `public`\n.\n\n```move`// Move 2020\nstruct Book {}\n\n// Move 2024\npublic struct Book {}\n`\n```\n\n## Method Syntax\n\n\nIn the new edition, functions which have a struct as the first argument are associated with the\nstruct. This means that the function can be called using the dot notation. Methods defined in the\nsame module with the type are automatically exported.\n\n\nMethods are automatically exported if the type is defined in the same module as the method. It is\nimpossible to export methods for types defined in other modules. However, you can create\ncustom aliases for methods in the module scope.\n\n\n```move`public fun count(c: &Counter): u64 { /* ... */ }\n\nfun use_counter() {\n    // move 2020\n    let count = counter::count(&c);\n\n    // move 2024\n    let count = c.count();\n}\n`\n```\n\n## Methods for Built-in Types\n\n\nIn Move 2024, some of the native and standard types received associated methods. For example, the\n`vector`\n type has a `to_string`\n method that converts the vector into a UTF8 string.\n\n```move`fun aliases() {\n    // vector to string and ascii string\n    let str: String = b\"Hello, World!\".to_string();\n    let ascii: ascii::String = b\"Hello, World!\".to_ascii_string();\n\n    // address to bytes\n    let bytes = @0xa11ce.to_bytes();\n}\n`\n```\n\nFor the full list of built-in aliases, refer to the\nStandard Library and\nSui Framework source code.\n\n## Borrowing Operator\n\n\nSome of the built-in types support borrowing operators. The borrowing operator is used to get a\nreference to the element at the specified index. The borrowing operator is defined as `[]`\n.\n\n```move`fun play_vec() {\n    let v = vector[1,2,3,4];\n    let first = &v[0];         // calls vector::borrow(v, 0)\n    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)\n    let first_copy = v[0];     // calls *vector::borrow(v, 0)\n}\n`\n```\n\nTypes that support the borrowing operator are:\n\n* `vector`\n\n\n* `sui::vec_map::VecMap`\n\n\n* `sui::table::Table`\n\n\n* `sui::bag::Bag`\n\n\n* `sui::object_table::ObjectTable`\n\n\n* `sui::object_bag::ObjectBag`\n\n\n* `sui::linked_table::LinkedTable`\n\n\nTo implement the borrowing operator for a custom type, you need to add a `#[syntax(index)]`\n\nattribute to the methods.\n\n```move`#[syntax(index)]\npublic fun borrow(c: &List<T>, key: String): &T { /* ... */ }\n\n#[syntax(index)]\npublic fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }\n`\n```\n\n## Method Aliases\n\n\nIn Move 2024, methods can be associated with types. The alias can be defined for any type locally to\nthe module; or publicly, if the type is defined in the same module.\n\n```move`// my_module.move\n// Local: type is foreign to the module\nuse fun my_custom_function as vector.do_magic;\n\n// sui-framework/kiosk/kiosk.move\n// Exported: type is defined in the same module\npublic use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;\n`\n```\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": " What is the `best practices for upgradeability` in the sui move language?"}, {"role": "assistant", "content": "\n# Upgradeability Practices\n\n\nTo talk about best practices for upgradeability, we need to first understand what can be upgraded in\na package. The base premise of upgradeability is that an upgrade should not break public\ncompatibility with the previous version. The parts of the module which can be used in dependent\npackages should not change their static signature. This applies to modules - a module can not be\nremoved from a package, public structs - they can be used in function signatures and public\nfunctions - they can be called from other packages.\n\n```move`// module can not be removed from the package\nmodule book::upgradable {\n    // dependencies can be changed (if they are not used in public signatures)\n    use std::string::String;\n    use sui::event; // can be removed\n\n    // public structs can not be removed and can't be changed\n    public struct Book has key {\n        id: UID,\n        title: String,\n    }\n\n    // public structs can not be removed and can't be changed\n    public struct BookCreated has copy, drop {\n        /* ... */\n    }\n\n    // public functions can not be removed and their signature can never change\n    // but the implementation can be changed\n    public fun create_book(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n\n        // can be removed and changed\n        event::emit(BookCreated {\n            /* ... */\n        })\n    }\n\n    // package-visibility functions can be removed and changed\n    public(package) fun create_book_package(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // entry functions can be removed and changed as long they're not public\n    entry fun create_book_entry(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // private functions can be removed and changed\n    fun create_book_internal(ctx: &mut TxContext): Book {\n        abort 0\n    }\n}\n`\n```\n\n\n## Versioning objects\n\n\n\nTo discard previous versions of the package, the objects can be versioned. As long as the object\ncontains a version field, and the code which uses the object expects and asserts a specific version,\nthe code can be force-migrated to the new version. Normally, after an upgrade, admin functions can\nbe used to update the version of the shared state, so that the new version of code can be used, and\nthe old version aborts with a version mismatch.\n\n```move`module book::versioned_state {\n\n    const EVersionMismatch: u64 = 0;\n\n    const VERSION: u8 = 1;\n\n    /// The shared state (can be owned too)\n    public struct SharedState has key {\n        id: UID,\n        version: u8,\n        /* ... */\n    }\n\n    public fun mutate(state: &mut SharedState) {\n        assert!(state.version == VERSION, EVersionMismatch);\n        // ...\n    }\n}\n`\n```\n\n## Versioning configuration with dynamic fields\n\n\n\nThere's a common pattern in Sui which allows changing the stored configuration of an object while\nretaining the same object signature. This is done by keeping the base object simple and versioned\nand adding an actual configuration object as a dynamic field. Using this anchor pattern, the\nconfiguration can be changed with package upgrades while keeping the same base object signature.\n\n```move`module book::versioned_config {\n    use sui::vec_map::VecMap;\n    use std::string::String;\n\n    /// The base object\n    public struct Config has key {\n        id: UID,\n        version: u16\n    }\n\n    /// The actual configuration\n    public struct ConfigV1 has store {\n        data: Bag,\n        metadata: VecMap<String, String>\n    }\n\n    // ...\n}\n`\n```\n\n## Modular architecture\n\n\nThis section is coming soon!\n\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are the steps for  `Building against and Limits` in the sui move language?"}, {"role": "assistant", "content": "\n# Building against Limits\n\n\nTo guarantee the safety and security of the network, Sui has certain limits and restrictions. These\nlimits are in place to prevent abuse and to ensure that the network remains stable and efficient.\nThis guide provides an overview of these limits and restrictions, and how to build your application\nto work within them.\n\nThe limits are defined in the protocol configuration and are enforced by the network. If any of the\nlimits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of\nthe protocol, can only be changed through a network upgrade.\n\n## Transaction Size\n\n\nThe size of a transaction is limited to 128KB. This includes the size of the transaction payload,\nthe size of the transaction signature, and the size of the transaction metadata. If a transaction\nexceeds this limit, it will be rejected by the network.\n\n## Object Size\n\n\nThe size of an object is limited to 256KB. This includes the size of the object data. If an object\nexceeds this limit, it will be rejected by the network. While a single object cannot bypass this\nlimit, for more extensive storage options, one could use a combination of a base object with other\nattached to it using dynamic fields (eg Bag).\n\n## Single Pure Argument Size\n\n\nThe size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit\nwill result in execution failure. So in order to create a vector of more than ~500 addresses (given\nthat a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or\nin a Move function. Standard functions like `vector::append()`\n can join two vectors of ~16KB\nresulting in a ~32KB of data as a single value.\n\n## Maximum Number of Objects created\n\n\nThe maximum number of objects that can be created in a single transaction is 2048. If a transaction\nattempts to create more than 2048 objects, it will be rejected by the network. This also affects\ndynamic fields, as both the key and the value are objects.\nSo the maximum number of dynamic fields that can be created in a single transaction is 1024.\n\n## Maximum Number of Dynamic Fields created\n\n\nThe maximum number of dynamic fields that can be created in a single object is 1024. If an object\nattempts to create more than 1024 dynamic fields, it will be rejected by the network.\n\n## Maximum Number of Events\n\n\nThe maximum number of events that can be emitted in a single transaction is 1024. If a transaction\nattempts to emit more than 1024 events, it will be aborted.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How to handle  `errors` in the sui move language?"}, {"role": "assistant", "content": "\n# Better error handling\n\n\nWhenever execution encounters an abort, transaction fails and abort code is returned to the caller.\nMove VM returns the module name that aborted the transaction and the abort code. This behavior is\nnot fully transparent to the caller of the transaction, especially when a single function contains\nmultiple calls to the same function which may abort. In this case, the caller will not know which\ncall aborted the transaction, and it will be hard to debug the issue or provide meaningful error\nmessage to the user.\n\n```move`module book::module_a {\n    use book::module_b;\n\n    public fun do_something() {\n        let field_1 = module_b::get_field(1); // may abort with 0\n        /* ... a lot of logic ... */\n        let field_2 = module_b::get_field(2); // may abort with 0\n        /* ... some more logic ... */\n        let field_3 = module_b::get_field(3); // may abort with 0\n    }\n}\n`\n```\n\nThe example above illustrates the case when a single function contains multiple calls which may\nabort. If the caller of the `do_something`\n function receives an abort code `0`\n, it will be hard to\nunderstand which call to `module_b::get_field`\n aborted the transaction. To address this problem,\nthere are common patterns that can be used to improve error handling.\n\n## Rule 1: Handle all possible scenarios\n\n\nIt is considered a good practice to provide a safe \"check\" function that returns a boolean value\nindicating whether an operation can be performed safely. If the `module_b`\n provides a function\n`has_field`\n that returns a boolean value indicating whether a field exists, the `do_something`\n\nfunction can be rewritten as follows:\n\n```move`module book::module_a {\n    use book::module_b;\n\n    const ENoField: u64 = 0;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoField);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoField);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoField);\n        let field_3 = module_b::get_field(3);\n    }\n}\n`\n```\n\nBy adding custom checks before each call to `module_b::get_field`\n, the developer of the `module_a`\n\ntakes control over the error handling. And it allows implementing the second rule.\n\n## Rule 2: Abort with different codes\n\n\nThe second trick, once the abort codes are handled by the caller module, is to use different abort\ncodes for different scenarios. This way, the caller module can provide a meaningful error message to\nthe user. The `module_a`\n can be rewritten as follows:\n\n```move`module book::module_a {\n    use book::module_b;\n\n    const ENoFieldA: u64 = 0;\n    const ENoFieldB: u64 = 1;\n    const ENoFieldC: u64 = 2;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoFieldA);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoFieldB);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoFieldC);\n        let field_3 = module_b::get_field(3);\n    }\n}\n`\n```\n\nNow, the caller module can provide a meaningful error message to the user. If the caller receives an\nabort code `0`\n, it can be translated to \"Field 1 does not exist\". If the caller receives an abort\ncode `1`\n, it can be translated to \"Field 2 does not exist\". And so on.\n\n## Rule 3: Return bool instead of assert\n\n\nA developer is often tempted to add a public function that would assert all the conditions and abort\nthe execution. However, it is a better practice to create a function that returns a boolean value\ninstead. This way, the caller module can handle the error and provide a meaningful error message to\nthe user.\n\n```move`module book::some_app_assert {\n\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert_is_authorized();\n        // ...\n    }\n\n    public fun do_b() {\n        assert_is_authorized();\n        // ...\n    }\n\n    /// Don't do this\n    public fun assert_is_authorized() {\n        assert!(/* some condition */ true, ENotAuthorized);\n    }\n}\n`\n```\n\nThis module can be rewritten as follows:\n\n```move`module book::some_app {\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun do_b() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun is_authorized(): bool {\n        /* some condition */ true\n    }\n\n    // a private function can still be used to avoid code duplication for a case\n    // when the same condition with the same abort code is used in multiple places\n    fun assert_is_authorized() {\n        assert!(is_authorized(), ENotAuthorized);\n    }\n}\n`\n```\n\nUtilizing these three rules will make the error handling more transparent to the caller of the\ntransaction, and it will allow other developers to use custom abort codes in their modules.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What is `Coding Conventions in the sui move language?"}, {"role": "assistant", "content": "\n# Coding Conventions\n\n\n## Naming\n\n\n### Module\n\n\n1. Module names should be in `snake_case`\n.\n2. Module names should be descriptive and should not be too long.\n\n```move`module book::conventions { /* ... */ }\nmodule book::common_pracices { /* ... */ }\n`\n```\n\n### Constant\n\n\n1. Constants should be in `SCREAMING_SNAKE_CASE`\n.\n2. Error constants should be in `EPascalCase`\n\n\n```move`const MAX_PRICE: u64 = 1000;\nconst EInvalidInput: u64 = 0;\n`\n```\n\n### Function\n\n\n1. Function names should be in `snake_case`\n.\n2. Function names should be descriptive.\n\n```move`public fun add(a: u64, b: u64): u64 { a + b }\npublic fun create_if_not_exists() { /* ... */ }\n`\n```\n\n### Struct\n\n\n1. Struct names should be in `PascalCase`\n.\n2. Struct fields should be in `snake_case`\n.\n3. Capabilities should be suffixed with `Cap`\n.\n\n```move`public struct Hero has key {\n    id: UID\n    value: u64,\n    another_value: u64,\n}\n\npublic struct AdminCap has key { id: UID }\n`\n```\n\n### Struct Method\n\n\n1. Struct methods should be in `snake_case`\n.\n2. If there's multiple structs with the same method, the method should be prefixed with the struct\nname. In this case, an alias can be added to the method using `use fun`\n.\n\n```move`public fun value(h: &Hero): u64 { h.value }\n\npublic use fun hero_health as Hero.health;\npublic fun hero_health(h: &Hero): u64 { h.another_value }\n\npublic use fun boar_health as Boar.health;\npublic fun boar_health(b: &Boar): u64 { b.another_value }\n`\n```\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `Glossary` in the sui move language?"}, {"role": "assistant", "content": "\n# Appendix A: Glossary\n\n\n* Fast Path - term used to describe a transaction that does not involve shared objects, and can be\nexecuted without the need for consensus.\n\n* Parallel Execution - term used to describe the ability of the Sui runtime to execute transactions\nin parallel, including the ones that involve shared objects.\n\n* Internal Type - type that is defined within the module. Fields of this type can not be accessed\nfrom outside the module, and, in case of \"key\"-only abilities, can not be used in `public_*`\n\ntransfer functions.\n\n## Abilities\n\n\n* key - ability that allows the struct to be used as a key in the storage. On Sui, the key ability\nmarks an object and requires the first field to be a `id: UID`\n.\n\n* store - ability that allows the struct to be stored inside other objects. This ability relaxes\nrestrictions applied to internal structs, allowing `public_*`\n transfer functions to accept them as\narguments. It also enables the object to be stored as a dynamic field.\n\n* copy - ability that allows the struct to be copied. On Sui, the `copy`\n ability conflicts with the\n`key`\n ability, and can not be used together with it.\n\n* drop - ability that allows the struct to be ignored or discarded. On Sui, the `drop`\n ability\ncannot be used together with the `key`\n ability, as objects are not allowed to be ignored.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `Reserved Adresses` in the sui move language?"}, {"role": "assistant", "content": "\n# Appendix B: Reserved Addresses\n\n\nReserved addresses are special addresses that have a specific purpose on Sui. They stay the same\nbetween environments and are used for specific native operations.\n\n* `0x1`\n - address of the [Standard Library](./../move-basics/standard-library.html) (alias `std`\n)\n\n* `0x2`\n - address of the [Sui Framework](./../programmability/sui-framework.html) (alias `sui`\n)\n\n* `0x5`\n - address of the `SuiSystem`\n object\n\n* `0x6`\n - address of the system [`Clock`\n object](./../programmability/epoch-and-time.html)\n\n* `0x8`\n - address of the system `Random`\n object\n\n* `0x403`\n - address of the `DenyList`\n system object\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "How to `Contribute` in the sui move language?"}, {"role": "assistant", "content": "\n# Appendix D: Contributing\n\n\nTo contribute to this book, please, submit a pull request to the\nGitHub repository. The repository contains the source\nfiles for the book, written in mdBook format.\n\n"}]}
{"messages": [{"role": "system", "content": "SuiAI is a chat agent that’s proficient in the Move smart contract language"}, {"role": "user", "content": "What are `Acknowledgements` in the sui move language?"}, {"role": "assistant", "content": "\n# Appendix E: Acknowledgements\n\n\nThe Rust Book has been a great inspiration for this book. I am\npersonally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as\nI have learned a lot from it. This book is a small tribute to their work and an attempt to bring a\nsimilar learning experience to the Move community.\n\n"}]}
